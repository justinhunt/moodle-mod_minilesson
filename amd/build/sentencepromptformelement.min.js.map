{"version":3,"file":"sentencepromptformelement.min.js","sources":["../src/sentencepromptformelement.js"],"sourcesContent":["import Log from \"core/log\";\n\nconst regionSelector = regionname => `[data - region = \"${regionname}\"]`;\n\nexport const registerElement = ({elementid}) => {\n    const element = document.getElementById(elementid);\n    if (element) {\n        Log.debug(element);\n        const textarea = element.querySelector(regionSelector('textarea'));\n        const lineNumbersEle = element.querySelector(regionSelector('lines'));\n\n        const textareaStyles = getComputedStyle(textarea);\n        [\n            'fontFamily',\n            'fontSize',\n            'fontWeight',\n            'letterSpacing',\n            'lineHeight',\n            'padding',\n        ].forEach((property) => {\n            lineNumbersEle.style[property] = textareaStyles[property];\n        });\n\n        const parseValue = (v) => v.endsWith('px') ? parseInt(v.slice(0, -2), 10) : 0;\n\n        const font = `${textareaStyles.fontSize} ${textareaStyles.fontFamily}`;\n        const paddingLeft = parseValue(textareaStyles.paddingLeft);\n        const paddingRight = parseValue(textareaStyles.paddingRight);\n\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        context.font = font;\n\n        const calculateNumLines = (str) => {\n            const textareaWidth = textarea.getBoundingClientRect().width - paddingLeft - paddingRight;\n            const words = str.split(' ');\n            let lineCount = 0;\n            let currentLine = '';\n            for (let i = 0; i < words.length; i++) {\n                const wordWidth = context.measureText(words[i] + ' ').width;\n                const lineWidth = context.measureText(currentLine).width;\n\n                if (lineWidth + wordWidth > textareaWidth) {\n                    lineCount++;\n                    currentLine = words[i] + ' ';\n                } else {\n                    currentLine += words[i] + ' ';\n                }\n            }\n\n            if (currentLine.trim() !== '') {\n                lineCount++;\n            }\n\n            return lineCount;\n        };\n\n        const calculateLineNumbers = () => {\n            const lines = textarea.value.split('\\n');\n            const numLines = lines.map((line) => calculateNumLines(line));\n\n            let i = 1;\n            const lineNumbers = [];\n            while (numLines.length > 0) {\n                const numLinesOfSentence = numLines.shift();\n                lineNumbers.push(i);\n                if (numLinesOfSentence > 1) {\n                    Array(numLinesOfSentence - 1).fill('').forEach(() => lineNumbers.push(''));\n                }\n                i++;\n            }\n\n            return lineNumbers;\n        };\n\n        const displayLineNumbers = () => {\n            const lineNumbers = calculateLineNumbers();\n            lineNumbersEle.innerHTML = Array.from(\n                {length: lineNumbers.length},\n                (_, i) => ` < div > ${lineNumbers[i] || '&nbsp;'} < / div > `\n            ).join('');\n        };\n\n        textarea.addEventListener('input', () => {\n            displayLineNumbers();\n        });\n\n        displayLineNumbers();\n\n        const ro = new ResizeObserver(() => {\n            const rect = textarea.getBoundingClientRect();\n            lineNumbersEle.style.height = `${rect.height}px`;\n            displayLineNumbers();\n        });\n        ro.observe(textarea);\n\n        textarea.addEventListener('scroll', () => {\n            lineNumbersEle.scrollTop = textarea.scrollTop;\n        });\n    }\n};"],"names":["regionSelector","regionname","_ref","elementid","element","document","getElementById","debug","textarea","querySelector","lineNumbersEle","textareaStyles","getComputedStyle","forEach","property","style","parseValue","v","endsWith","parseInt","slice","font","fontSize","fontFamily","paddingLeft","paddingRight","context","createElement","getContext","calculateNumLines","str","textareaWidth","getBoundingClientRect","width","words","split","lineCount","currentLine","i","length","wordWidth","measureText","trim","calculateLineNumbers","numLines","value","map","line","lineNumbers","numLinesOfSentence","shift","push","Array","fill","displayLineNumbers","innerHTML","from","_","join","addEventListener","ResizeObserver","rect","height","observe","scrollTop"],"mappings":"0PAEMA,eAAiBC,wCAAmCA,0CAE3BC,WAACC,UAACA,sBACvBC,QAAUC,SAASC,eAAeH,cACpCC,QAAS,cACLG,MAAMH,eACJI,SAAWJ,QAAQK,cAAcT,eAAe,aAChDU,eAAiBN,QAAQK,cAAcT,eAAe,UAEtDW,eAAiBC,iBAAiBJ,WAEpC,aACA,WACA,aACA,gBACA,aACA,WACFK,SAASC,WACPJ,eAAeK,MAAMD,UAAYH,eAAeG,mBAG9CE,WAAcC,GAAMA,EAAEC,SAAS,MAAQC,SAASF,EAAEG,MAAM,GAAI,GAAI,IAAM,EAEtEC,eAAUV,eAAeW,qBAAYX,eAAeY,YACpDC,YAAcR,WAAWL,eAAea,aACxCC,aAAeT,WAAWL,eAAec,cAGzCC,QADSrB,SAASsB,cAAc,UACfC,WAAW,MAClCF,QAAQL,KAAOA,WAETQ,kBAAqBC,YACjBC,cAAgBvB,SAASwB,wBAAwBC,MAAQT,YAAcC,aACvES,MAAQJ,IAAIK,MAAM,SACpBC,UAAY,EACZC,YAAc,OACb,IAAIC,EAAI,EAAGA,EAAIJ,MAAMK,OAAQD,IAAK,OAC7BE,UAAYd,QAAQe,YAAYP,MAAMI,GAAK,KAAKL,MACpCP,QAAQe,YAAYJ,aAAaJ,MAEnCO,UAAYT,eACxBK,YACAC,YAAcH,MAAMI,GAAK,KAEzBD,aAAeH,MAAMI,GAAK,UAIP,KAAvBD,YAAYK,QACZN,YAGGA,WAGLO,qBAAuB,WAEnBC,SADQpC,SAASqC,MAAMV,MAAM,MACZW,KAAKC,MAASlB,kBAAkBkB,YAEnDT,EAAI,QACFU,YAAc,QACbJ,SAASL,OAAS,GAAG,OAClBU,mBAAqBL,SAASM,QACpCF,YAAYG,KAAKb,GACbW,mBAAqB,GACrBG,MAAMH,mBAAqB,GAAGI,KAAK,IAAIxC,SAAQ,IAAMmC,YAAYG,KAAK,MAE1Eb,WAGGU,aAGLM,mBAAqB,WACjBN,YAAcL,uBACpBjC,eAAe6C,UAAYH,MAAMI,KAC7B,CAACjB,OAAQS,YAAYT,SACrB,CAACkB,EAAGnB,uBAAkBU,YAAYV,IAAM,0BAC1CoB,KAAK,KAGXlD,SAASmD,iBAAiB,SAAS,KAC/BL,wBAGJA,qBAEW,IAAIM,gBAAe,WACpBC,KAAOrD,SAASwB,wBACtBtB,eAAeK,MAAM+C,iBAAYD,KAAKC,aACtCR,wBAEDS,QAAQvD,UAEXA,SAASmD,iBAAiB,UAAU,KAChCjD,eAAesD,UAAYxD,SAASwD"}