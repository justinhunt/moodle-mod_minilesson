{"version":3,"file":"ttaudiohelper.min.js","sources":["../src/ttaudiohelper.js"],"sourcesContent":["define(\n    ['jquery', 'core/log', 'mod_minilesson/ttwavencoder', 'mod_minilesson/ttstreamer', 'mod_minilesson/ttazure'],\n    function ($, log, wavencoder, audiostreamer, azurestreamer) {\n        \"use strict\"; // jshint ;_;\n        /*\n        This file is the engine that drives audio rec and canvas drawing. TT Recorder is the just the glory kid\n         */\n\n        log.debug('TT Audio Helper initialising');\n\n        return {\n            encodingconfig: null,\n            streamer: null,\n            encoder: null,\n            microphone: null,\n            isRecording: false,\n            audioContext: null,\n            processor: null,\n            uniqueid: null,\n            alreadyhadsound: false, //only start silence detection after we got a sound. Silence detection is end of speech.\n            silencecount: 0, //how many intervals of consecutive silence so far\n            silenceintervals: 15, //how many consecutive silence intervals (100ms) = silence detected\n            silencelevel: 25, //below this volume level = silence\n            enablesilencedetection: true,\n\n            // wav config for encoding to wav\n            wavconfig: {\n                bufferLen: 4096,\n                numChannels: 2,\n                desiredSampleRate: 48000,\n                mimeType: 'audio/wav'\n            },\n            //streaming config for encoding to pcm and later base64\n            // TO DO: wav config might work just as well. test.\n            streamingconfig: {\n                bufferLen: 4096,\n                numChannels: 1,\n                desiredSampleRate: 16000,\n                mimeType: 'audio/wav'\n            },\n\n            //for making multiple instances\n            clone: function () {\n                return $.extend(true, {}, this);\n            },\n\n\n            init: function (waveHeight, uniqueid, therecorder) {\n\n                this.waveHeight = waveHeight;\n                this.uniqueid = uniqueid;\n                this.therecorder = therecorder;\n                this.region = therecorder.region;\n                if (this.therecorder.is_streaming) {\n                    this.encodingconfig = this.streamingconfig;\n                } else {\n                    this.encodingconfig = this.wavconfig;\n                }\n                this.prepare_html();\n                window.AudioContext = window.AudioContext || window.webkitAudioContext;\n            },\n\n            onStop: function () { },\n            onStream: function () { },\n            onSocketReady: function () { },\n            onError: function () { },\n            onfinalspeechcapture: function (speechtext) { },\n            oninterimspeechcapture: function (speechtext) { },\n\n\n            prepare_html: function () {\n                this.canvas = $('#' + this.uniqueid + \"_waveform\");\n                this.canvasCtx = this.canvas[0].getContext(\"2d\");\n            },\n\n            start: function () {\n\n                var that = this;\n\n                // Audio context\n                this.audioContext = new AudioContext(\n                    {\n                        sampleRate: this.encodingconfig.desiredSampleRate\n                    }\n                );\n\n                this.processor = this.audioContext.createScriptProcessor(\n                    this.encodingconfig.bufferLen,\n                    this.encodingconfig.numChannels,\n                    this.encodingconfig.numChannels\n                );\n\n                this.processor.connect(this.audioContext.destination);\n\n\n                var gotStreamMethod = function (stream) {\n\n                    that.isRecording = true;\n                    that.tracks = stream.getTracks();\n\n                    //lets check the noise suppression and echo reduction on these\n                    for (var i = 0; i < that.tracks.length; i++) {\n                        var track = that.tracks[i];\n                        if (track.kind == \"audio\") {\n                            var settings = track.getSettings();\n                            if (settings.noiseSuppression) {\n                                log.debug(\"Noise Suppression is on\");\n                            } else {\n                                log.debug(\"Noise Suppression is off\");\n                            }\n                            if (settings.echoCancellation) {\n                                log.debug(\"Echo Cancellation is on\");\n                            } else {\n                                log.debug(\"Echo Cancellation is off\");\n                            }\n                        }\n                    }\n\n                    // Create a MediaStreamAudioSourceNode for the microphone\n                    that.microphone = that.audioContext.createMediaStreamSource(stream);\n\n                    // Connect the AudioBufferSourceNode to the gainNode\n                    that.microphone.connect(that.processor);\n\n                    //if we have a streaming transcriber we need to initialize it\n                    if (that.therecorder.is_streaming) {\n                        if (that.therecorder.speechtokentype === 'azure') {\n                            that.streamer = azurestreamer.clone();\n                        } else {\n                            that.streamer = audiostreamer.clone();\n                        }\n                        that.streamer.init(that.therecorder.speechtoken,that.therecorder.speechtokenregion, that);\n                        that.enablesilencedetection = false;\n                    }\n\n                    //Alert TT recorder that we are ready to go (it will do visuals and manage state of recorder)\n                    that.onStream(stream);\n\n\n                    // Init WAV encoder\n                    that.encoder = wavencoder.clone();\n                    that.encoder.init(that.audioContext.sampleRate, that.encodingconfig.numChannels);\n\n                    // Give the node a function to process audio events\n                    that.processor.onaudioprocess = function (event) {\n                        var thebuffers = that.getBuffers(event);\n                        that.encoder.audioprocess(thebuffers);\n                        if (that.streamer) {\n                            that.streamer.audioprocess(thebuffers);\n                        }\n                    };\n\n                    that.listener = that.audioContext.createAnalyser();\n                    that.microphone.connect(that.listener);\n                    that.listener.fftSize = 2048; // 256\n\n                    that.bufferLength = that.listener.frequencyBinCount;\n                    that.analyserData = new Uint8Array(that.bufferLength);\n                    that.volumeData = new Uint8Array(that.bufferLength);\n\n                    //reset canvas and silence detection\n                    that.canvasCtx.clearRect(0, 0, that.canvas.width() * 2, that.waveHeight * 2);\n                    that.alreadyhadsound = false;\n                    that.silencecount = 0;\n\n                    that.interval = setInterval(function () {\n                        that.drawWave();\n                        that.detectSilence();\n                    }, 100);\n\n                };\n\n                //for ios we need to do this to keep playback volume high\n                if (\"audioSession\" in navigator) {\n                    navigator.audioSession.type = 'play-and-record';\n                    console.log(\"AudioSession API is supported\");\n                }\n\n                // Mic permission\n                navigator.mediaDevices.getUserMedia({\n                    audio: true,\n                    video: false\n                }).then(gotStreamMethod).catch(this.onError);\n            },\n\n            stop: function () {\n                var that = this;\n                clearInterval(this.interval);\n                this.canvasCtx.clearRect(0, 0, this.canvas.width() * 2, this.waveHeight * 2);\n                this.isRecording = false;\n                this.silencecount = 0;\n                this.alreadyhadsound = false;\n                this.therecorder.update_audio('isRecording', false);\n                //we set a timeout to allow the audiocontext buffer to fill up since we can't flush it\n                //if we don't we may miss 1s of audio at the end\n                setTimeout(function () {\n                    //we check audiocontext is not in an odd state before closing\n                    //superclickers can get it in an odd state\n                    if (that.audioContext !== null && that.audioContext.state !== \"closed\") {\n                        that.audioContext.close();\n                    }\n                    that.processor.disconnect();\n                    that.tracks.forEach(track => track.stop());\n                    that.onStop(that.encoder.finish());\n                    if (that.streamer) {\n                        that.streamer.finish();\n                    }\n                }, 1000);\n\n            },\n\n            getBuffers: function (event) {\n                var buffers = [];\n                for (var ch = 0; ch < this.encodingconfig.numChannels; ++ch) {\n                    buffers[ch] = event.inputBuffer.getChannelData(ch);\n                }\n                return buffers;\n            },\n\n            detectSilence: function () {\n\n                if (!this.enablesilencedetection) {\n                    return; }\n\n                this.listener.getByteFrequencyData(this.volumeData);\n\n                let sum = 0;\n                for (var vindex = 0; vindex < this.volumeData.length; vindex++) {\n                    sum += this.volumeData[vindex] * this.volumeData[vindex];\n                }\n\n                var volume = Math.sqrt(sum / this.volumeData.length);\n                // log.debug(\"volume: \" + volume + ', hadsound: ' + this.alreadyhadsound);\n                //if we already had a sound, we are looking for end of speech\n                if (volume < this.silencelevel && this.alreadyhadsound) {\n                    this.silencecount++;\n                    if (this.silencecount >= this.silenceintervals) {\n                        this.therecorder.silence_detected();\n                    }\n                    //if we have a sound, reset silence count to zero, and flag that we have started\n                } else if (volume > this.silencelevel) {\n                    this.alreadyhadsound = true;\n                    this.silencecount = 0;\n                }\n            },\n\n            drawWave: function () {\n\n                var width = this.canvas.width() * 2;\n                this.listener.getByteTimeDomainData(this.analyserData);\n\n                this.canvasCtx.fillStyle = '#F5F5FE';\n                this.canvasCtx.fillRect(0, 0, width, this.waveHeight * 2);\n\n                this.canvasCtx.lineWidth = 5;\n                this.canvasCtx.strokeStyle = 'gray';\n                this.canvasCtx.beginPath();\n\n                var slicewaveWidth = width / this.bufferLength;\n                var x = 0;\n\n                for (var i = 0; i < this.bufferLength; i++) {\n                    var v = this.analyserData[i] / 128.0;\n                    var y = v * this.waveHeight;\n\n                    if (i === 0) {\n                        // this.canvasCtx.moveTo(x, y);\n                    } else {\n                        this.canvasCtx.lineTo(x, y);\n                    }\n\n                    x += slicewaveWidth;\n                }\n\n                this.canvasCtx.lineTo(width, this.waveHeight);\n                this.canvasCtx.stroke();\n\n            }\n        }; //end of this declaration\n\n\n    }\n);"],"names":["define","$","log","wavencoder","audiostreamer","azurestreamer","debug","encodingconfig","streamer","encoder","microphone","isRecording","audioContext","processor","uniqueid","alreadyhadsound","silencecount","silenceintervals","silencelevel","enablesilencedetection","wavconfig","bufferLen","numChannels","desiredSampleRate","mimeType","streamingconfig","clone","extend","this","init","waveHeight","therecorder","region","is_streaming","prepare_html","window","AudioContext","webkitAudioContext","onStop","onStream","onSocketReady","onError","onfinalspeechcapture","speechtext","oninterimspeechcapture","canvas","canvasCtx","getContext","start","that","sampleRate","createScriptProcessor","connect","destination","navigator","audioSession","type","console","mediaDevices","getUserMedia","audio","video","then","stream","tracks","getTracks","i","length","track","kind","settings","getSettings","noiseSuppression","echoCancellation","createMediaStreamSource","speechtokentype","speechtoken","speechtokenregion","onaudioprocess","event","thebuffers","getBuffers","audioprocess","listener","createAnalyser","fftSize","bufferLength","frequencyBinCount","analyserData","Uint8Array","volumeData","clearRect","width","interval","setInterval","drawWave","detectSilence","catch","stop","clearInterval","update_audio","setTimeout","state","close","disconnect","forEach","finish","buffers","ch","inputBuffer","getChannelData","getByteFrequencyData","sum","vindex","volume","Math","sqrt","silence_detected","getByteTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","slicewaveWidth","x","y","lineTo","stroke"],"mappings":"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"}