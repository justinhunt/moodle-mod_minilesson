{"version":3,"file":"ttaudiohelper.min.js","sources":["../src/ttaudiohelper.js"],"sourcesContent":["define(['jquery', 'core/log', 'mod_minilesson/ttwavencoder', 'mod_minilesson/ttstreamer'],\n    function ($, log, wavencoder, audiostreamer) {\n    \"use strict\"; // jshint ;_;\n    /*\n    This file is the engine that drives audio rec and canvas drawing. TT Recorder is the just the glory kid\n     */\n\n    log.debug('TT Audio Helper initialising');\n\n    return {\n        encodingconfig: null,\n        streamer: null,\n        encoder: null,\n        microphone: null,\n        isRecording: false,\n        audioContext: null,\n        processor: null,\n        uniqueid: null,\n        alreadyhadsound: false, //only start silence detection after we got a sound. Silence detection is end of speech.\n        silencecount: 0, //how many intervals of consecutive silence so far\n        silenceintervals: 15, //how many consecutive silence intervals (100ms) = silence detected\n        silencelevel: 25, //below this volume level = silence\n        enablesilencedetection: true,\n\n        // wav config for encoding to wav\n        wavconfig: {\n            bufferLen: 4096,\n            numChannels: 2,\n            desiredSampleRate: 48000,\n            mimeType: 'audio/wav'\n        },\n        //streaming config for encoding to pcm and later base64\n        // TO DO: wav config might work just as well. test.\n        streamingconfig: {\n            bufferLen: 4096,\n            numChannels: 1,\n            desiredSampleRate: 16000,\n            mimeType: 'audio/wav'\n        },\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n\n        init: function(waveHeight, uniqueid, therecorder) {\n\n            this.waveHeight = waveHeight;\n            this.uniqueid=uniqueid;\n            this.therecorder= therecorder;\n            this.region = therecorder.region;\n            if(this.therecorder.is_streaming){\n                this.encodingconfig = this.streamingconfig;\n            } else {\n                this.encodingconfig = this.wavconfig;\n            }\n            this.prepare_html();\n            window.AudioContext = window.AudioContext || window.webkitAudioContext;\n        },\n\n        onStop: function() {},\n        onStream: function() {},\n        onSocketReady: function() {},\n        onError: function() {},\n        onfinalspeechcapture: function (speechtext) {},\n        oninterimspeechcapture: function (speechtext) {},\n\n\n        prepare_html: function(){\n            this.canvas =$('#' + this.uniqueid + \"_waveform\");\n            this.canvasCtx = this.canvas[0].getContext(\"2d\");\n        },\n\n        start: function() {\n\n            var that =this;\n\n            // Audio context\n            this.audioContext = new AudioContext(\n                {\n                    sampleRate: this.encodingconfig.desiredSampleRate\n                });\n\n            this.processor = this.audioContext.createScriptProcessor(\n                this.encodingconfig.bufferLen,\n                this.encodingconfig.numChannels,\n                this.encodingconfig.numChannels);\n\n            this.processor.connect(this.audioContext.destination);\n\n\n            var gotStreamMethod= function(stream) {\n\n                that.isRecording = true;\n                that.tracks = stream.getTracks();\n\n                //lets check the noise suppression and echo reduction on these\n                for(var i=0; i<that.tracks.length; i++){\n                    var track = that.tracks[i];\n                    if(track.kind == \"audio\"){\n                        var settings = track.getSettings();\n                        if(settings.noiseSuppression){\n                            log.debug(\"Noise Suppression is on\");\n                        }else{\n                            log.debug(\"Noise Suppression is off\");\n                        }\n                        if(settings.echoCancellation){\n                            log.debug(\"Echo Cancellation is on\");\n                        }else{\n                            log.debug(\"Echo Cancellation is off\");\n                        }\n                    }\n                }\n\n                // Create a MediaStreamAudioSourceNode for the microphone\n                that.microphone = that.audioContext.createMediaStreamSource(stream);\n\n                // Connect the AudioBufferSourceNode to the gainNode\n                that.microphone.connect(that.processor);\n\n                //if we have a streaming transcriber we need to initialize it\n                if(that.therecorder.is_streaming){\n                    that.streamer = audiostreamer.clone();\n                    that.streamer.init(that.therecorder.streamingtoken, that);\n                    that.enablesilencedetection = false;\n                }else{\n                    //This is hacky, but we need to tell TTRecorder that we have started\n                    //so it knows state and can change visuals\n                    //but streaming transcription ignores first few seconds of audio\n                    //so we dont want to make that notification if its streaming (yet)\n                    //so only if we are not streaming, we notify that we have started\n                    //streaming will notify when it is ready\n                    that.onStream(stream);\n                   // that.therecorder.update_audio('isRecording',true);\n                }\n\n                // Init WAV encoder\n                that.encoder = wavencoder.clone();\n                that.encoder.init(that.audioContext.sampleRate, that.encodingconfig.numChannels);\n\n                // Give the node a function to process audio events\n                that.processor.onaudioprocess = function(event) {\n                    that.encoder.audioprocess(that.getBuffers(event));\n                    if(that.streamer){\n                        that.streamer.audioprocess(that.getBuffers(event));\n                    }\n                };\n\n                that.listener = that.audioContext.createAnalyser();\n                that.microphone.connect(that.listener);\n                that.listener.fftSize = 2048; // 256\n\n                that.bufferLength = that.listener.frequencyBinCount;\n                that.analyserData = new Uint8Array(that.bufferLength);\n                that.volumeData = new Uint8Array(that.bufferLength);\n\n                //reset canvas and silence detection\n                that.canvasCtx.clearRect(0, 0, that.canvas.width()*2, that.waveHeight*2);\n                that.alreadyhadsound= false;\n                that.silencecount= 0;\n\n                that.interval = setInterval(function() {\n                    that.drawWave();\n                    that.detectSilence();\n                }, 100);\n\n            };\n\n            //for ios we need to do this to keep playback volume high\n            if (\"audioSession\" in navigator) {\n                navigator.audioSession.type = 'play-and-record';\n                console.log(\"AudioSession API is supported\");\n            }\n\n            // Mic permission\n            navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: false\n            }).then(gotStreamMethod).catch(this.onError);\n        },\n\n        stop: function() {\n            var that = this;\n            clearInterval(this.interval);\n            this.canvasCtx.clearRect(0, 0, this.canvas.width()*2, this.waveHeight * 2);\n            this.isRecording = false;\n            this.silencecount=0;\n            this.alreadyhadsound=false;\n            this.therecorder.update_audio('isRecording',false);\n            //we set a timeout to allow the audiocontext buffer to fill up since we can't flush it\n            //if we don't we may miss 1s of audio at the end\n            setTimeout(function() {\n                //we check audiocontext is not in an odd state before closing\n                //superclickers can get it in an odd state\n                if (that.audioContext!==null && that.audioContext.state !== \"closed\") {\n                    that.audioContext.close();\n                }\n                that.processor.disconnect();\n                that.tracks.forEach(track => track.stop());\n                that.onStop(that.encoder.finish());\n                if(that.streamer){\n                    that.streamer.finish();\n                }\n            },1000);\n\n        },\n\n        getBuffers: function(event) {\n            var buffers = [];\n            for (var ch = 0; ch < this.encodingconfig.numChannels; ++ch) {\n                buffers[ch] = event.inputBuffer.getChannelData(ch);\n            }\n            return buffers;\n        },\n\n        detectSilence: function () {\n\n            if(!this.enablesilencedetection){return;}\n\n            this.listener.getByteFrequencyData(this.volumeData);\n\n            let sum = 0;\n            for (var vindex =0; vindex <this.volumeData.length;vindex++) {\n                sum += this.volumeData[vindex] * this.volumeData[vindex];\n            }\n\n            var volume = Math.sqrt(sum / this.volumeData.length);\n           // log.debug(\"volume: \" + volume + ', hadsound: ' + this.alreadyhadsound);\n            //if we already had a sound, we are looking for end of speech\n            if(volume < this.silencelevel && this.alreadyhadsound){\n                this.silencecount++;\n                if(this.silencecount>=this.silenceintervals){\n                    this.therecorder.silence_detected();\n                }\n            //if we have a sound, reset silence count to zero, and flag that we have started\n            }else if(volume > this.silencelevel){\n                this.alreadyhadsound = true;\n                this.silencecount=0;\n            }\n        },\n\n        drawWave: function() {\n\n            var width = this.canvas.width() * 2;\n            this.listener.getByteTimeDomainData(this.analyserData);\n\n            this.canvasCtx.fillStyle = 'white';\n            this.canvasCtx.fillRect(0, 0, width, this.waveHeight*2);\n\n            this.canvasCtx.lineWidth = 5;\n            this.canvasCtx.strokeStyle = 'gray';\n            this.canvasCtx.beginPath();\n\n            var slicewaveWidth = width / this.bufferLength;\n            var x = 0;\n\n            for (var i = 0; i < this.bufferLength; i++) {\n\n                var v = this.analyserData[i] / 128.0;\n                var y = v * this.waveHeight;\n\n                if (i === 0) {\n                    // this.canvasCtx.moveTo(x, y);\n                } else {\n                    this.canvasCtx.lineTo(x, y);\n                }\n\n                x += slicewaveWidth;\n            }\n\n            this.canvasCtx.lineTo(width, this.waveHeight);\n            this.canvasCtx.stroke();\n\n        }\n    }; //end of this declaration\n\n\n});"],"names":["define","$","log","wavencoder","audiostreamer","debug","encodingconfig","streamer","encoder","microphone","isRecording","audioContext","processor","uniqueid","alreadyhadsound","silencecount","silenceintervals","silencelevel","enablesilencedetection","wavconfig","bufferLen","numChannels","desiredSampleRate","mimeType","streamingconfig","clone","extend","this","init","waveHeight","therecorder","region","is_streaming","prepare_html","window","AudioContext","webkitAudioContext","onStop","onStream","onSocketReady","onError","onfinalspeechcapture","speechtext","oninterimspeechcapture","canvas","canvasCtx","getContext","start","that","sampleRate","createScriptProcessor","connect","destination","navigator","audioSession","type","console","mediaDevices","getUserMedia","audio","video","then","stream","tracks","getTracks","i","length","track","kind","settings","getSettings","noiseSuppression","echoCancellation","createMediaStreamSource","streamingtoken","onaudioprocess","event","audioprocess","getBuffers","listener","createAnalyser","fftSize","bufferLength","frequencyBinCount","analyserData","Uint8Array","volumeData","clearRect","width","interval","setInterval","drawWave","detectSilence","catch","stop","clearInterval","update_audio","setTimeout","state","close","disconnect","forEach","finish","buffers","ch","inputBuffer","getChannelData","getByteFrequencyData","sum","vindex","volume","Math","sqrt","silence_detected","getByteTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","slicewaveWidth","x","y","lineTo","stroke"],"mappings":"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"}