{"version":3,"file":"ttbrowserrec.min.js","sources":["../src/ttbrowserrec.js"],"sourcesContent":["/* jshint ignore:start */\ndefine(['jquery', 'core/log', 'mod_minilesson/ttwavencoder'], function ($, log, wavencoder) {\n\n    \"use strict\"; // jshint ;_;\n\n    log.debug('mod_minilesson browser speech rec: initialising');\n\n    return {\n\n        recognition: null,\n        recognizing: false,\n        final_transcript: '',\n        interim_transcript: '',\n        start_timestamp: 0,\n        lang: 'en-US',\n        interval: 0,\n        browsertype: '',\n\n        audioContext: null,\n        processor: null,\n        microphone: null,\n        encoder: null,\n        listener: null,\n\n        // wav config for encoding to wav\n        wavconfig: {\n            bufferLen: 4096,\n            numChannels: 2,\n            desiredSampleRate: 48000,\n            mimeType: 'audio/wav'\n        },\n\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        will_work_ok: function (opts) {\n            //let's check if we are in an iframe\n            var is_iframe = false;\n            if (window.self !== window.top) {\n                is_iframe = true;\n            }\n\n            //is mobileapp ?\n            var is_mobileapp = false;\n            if (navigator.userAgent.indexOf(\"MoodleMobile\") > -1) {\n                is_mobileapp = true;\n            }\n\n            //Brave looks like it does speech rec, but it doesn't\n            var brave = typeof navigator.brave !== 'undefined';\n            if (brave) {\n                this.browsertype = 'brave';\n            }\n\n            //Edge may or may not work, but its hard to tell from the browser agent\n            var edge = navigator.userAgent.toLowerCase().indexOf(\"edg/\") > -1;\n            if (edge && this.browsertype === '') {\n                this.browsertype = 'edge';\n            }\n\n            //Safari may or may not work, but its hard to tell from the browser agent\n            var has_chrome = navigator.userAgent.indexOf('Chrome') > -1;\n            var has_safari = navigator.userAgent.indexOf(\"Safari\") > -1;\n            var is_ios = (navigator.userAgent.indexOf(\"iPhone\") > -1 ||\n                navigator.userAgent.indexOf(\"iPad\") > -1);\n            var safari = has_safari && !has_chrome;\n            if (safari && this.browsertype === '') {\n                this.browsertype = 'safari';\n            }\n\n            //This is feature detection, and for chrome it can be trusted.\n            var is_android = navigator.userAgent.indexOf(\"Android\") > -1;\n            var hasspeechrec = ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window);\n            if (hasspeechrec && this.browsertype === '' && has_chrome) {\n                this.browsertype = 'chrome';\n            }\n\n            //This is feature detection, and for chrome it can be trusted.\n            // The others might say they do speech rec, but that does not mean it works\n            // we know safari in webapp does not so we nix that here\n            if (is_mobileapp && is_ios) {\n                return false;\n            } else if (this.browsertype === 'brave') {\n                return false;\n            } else {\n                return hasspeechrec;\n            }\n        },\n\n        init: function (lang, waveheight, uniqueid) {\n            var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;\n            var is_android = navigator.userAgent.indexOf(\"Android\") > -1;\n            this.recognition = new SpeechRecognition();\n            this.recognition.continuous = true;\n            //a bug in android chrome means it reverses isfinal true and false, so we cant use interim results\n            this.recognition.interimResults = !is_android;\n            this.lang = lang;\n            this.waveHeight = waveheight;\n            this.uniqueid = uniqueid;\n            this.prepare_html();\n            this.register_events();\n            window.AudioContext = window.AudioContext || window.webkitAudioContext;\n        },\n\n        onStop: function () { },\n\n        prepare_html: function () {\n            this.canvas = $('#' + this.uniqueid + \"_waveform\");\n            this.canvasCtx = this.canvas[0].getContext(\"2d\");\n        },\n\n        set_grammar: function (grammar) {\n            var SpeechGrammarList = SpeechGrammarList || webkitSpeechGrammarList;\n            if (SpeechGrammarList) {\n                var speechRecognitionList = new SpeechGrammarList();\n                speechRecognitionList.addFromString(grammar, 1);\n                this.recognition.grammars = speechRecognitionList;\n            }\n        },\n\n        start: function () {\n            var that = this;\n\n            //If we already started ignore this\n            if (this.recognizing) {\n                return;\n            }\n            this.recognizing = true;\n            this.final_transcript = '';\n            this.interim_transcript = '';\n            this.recognition.lang = this.lang;//select_dialect.value;\n            this.recognition.start();\n            this.start_timestamp = Date.now();//event.timeStamp;\n            that.onstart();\n\n            // Audio context\n            this.audioContext = new AudioContext(\n                {\n                    sampleRate: this.wavconfig.desiredSampleRate\n                }\n            );\n\n            this.processor = this.audioContext.createScriptProcessor(\n                this.wavconfig.bufferLen,\n                this.wavconfig.numChannels,\n                this.wavconfig.numChannels\n            );\n\n            this.processor.connect(this.audioContext.destination);\n\n            var gotStreamMethod = function (stream) {\n                if (!that.recognizing) {\n                    stream.getTracks().forEach(track => track.stop());\n                    return;\n                }\n                if (that.audioContext.state === 'suspended') {\n                    that.audioContext.resume();\n                }\n                that.tracks = stream.getTracks();\n\n                // Create a MediaStreamAudioSourceNode for the microphone\n                that.microphone = that.audioContext.createMediaStreamSource(stream);\n\n                // Connect the AudioBufferSourceNode to the gainNode\n                that.microphone.connect(that.processor);\n\n                // Init WAV encoder\n                that.encoder = wavencoder.clone();\n                that.encoder.init(that.audioContext.sampleRate, that.wavconfig.numChannels);\n\n                // Give the node a function to process audio events\n                that.processor.onaudioprocess = function (event) {\n                    var thebuffers = that.getBuffers(event);\n                    that.encoder.audioprocess(thebuffers);\n                };\n\n                that.listener = that.audioContext.createAnalyser();\n                that.microphone.connect(that.listener);\n                that.listener.fftSize = 256;\n\n                that.bufferLength = that.listener.frequencyBinCount;\n                that.analyserData = new Uint8Array(that.bufferLength);\n\n                //kick off animation\n                that.interval = setInterval(function () {\n                    that.drawWave();\n                }, 100);\n            };\n\n            // Mic permission\n            navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: false\n            }).then(gotStreamMethod).catch(function (error) {\n                log.debug(error);\n                that.onerror(error);\n            });\n        },\n\n        stop: function () {\n            var that = this;\n            this.recognizing = false;\n            this.recognition.stop();\n            clearInterval(this.interval);\n\n            if (this.audioContext !== null && this.audioContext.state !== \"closed\") {\n                this.audioContext.close();\n            }\n            this.processor.disconnect();\n            if (this.tracks) {\n                this.tracks.forEach(track => track.stop());\n            }\n            if (this.encoder) {\n                this.onStop(this.encoder.finish());\n            }\n\n            this.canvasCtx.clearRect(0, 0, this.canvas.width() * 2, this.waveHeight * 2);\n            setTimeout(function () {\n                that.onfinalspeechcapture(that.final_transcript);\n            }, 1000);\n            this.onend();\n        },\n\n        register_events: function () {\n\n            var recognition = this.recognition;\n            var that = this;\n\n            recognition.onerror = function (event) {\n                if (event.error == 'no-speech') {\n                    log.debug('info_no_speech');\n                }\n                if (event.error == 'audio-capture') {\n                    log.debug('info_no_microphone');\n                }\n                if (event.error == 'not-allowed') {\n                    if (event.timeStamp - that.start_timestamp < 100) {\n                        log.debug('info_blocked');\n                    } else {\n                        log.debug('info_denied');\n                    }\n                }\n                that.onerror({ error: { name: event.error } });\n            };\n\n            recognition.onend = function () {\n                if (that.recognizing) {\n                    that.recognition.start();\n                }\n\n            };\n\n            recognition.onresult = function (event) {\n                for (var i = event.resultIndex; i < event.results.length; ++i) {\n                    // a bug on android chrome means it reverses isfinal true and false, so we cant use interim results\n                    if (event.results[i].isFinal) {\n                        that.final_transcript += event.results[i][0].transcript + ' ';\n                    } else {\n                        var provisional_transcript = that.final_transcript + event.results[i][0].transcript;\n                        //the interim and final events do not arrive in sequence, we dont want the length going down, its weird\n                        //so just dont respond when the sequence is wonky\n                        if (provisional_transcript.length < that.interim_transcript.length) {\n                            return;\n                        } else {\n                            that.interim_transcript = provisional_transcript;\n                        }\n                        that.oninterimspeechcapture(that.interim_transcript);\n                    }\n                }\n\n            };\n        },//end of register events\n\n        getBuffers: function (event) {\n            var buffers = [];\n            for (var ch = 0; ch < this.wavconfig.numChannels; ++ch) {\n                buffers[ch] = event.inputBuffer.getChannelData(ch);\n            }\n            return buffers;\n        },\n\n        drawWave: function () {\n\n            var width = this.canvas.width() * 2;\n            this.listener.getByteTimeDomainData(this.analyserData);\n\n            this.canvasCtx.fillStyle = '#F5F5FE';\n            this.canvasCtx.fillRect(0, 0, width, this.waveHeight * 2);\n\n            this.canvasCtx.lineWidth = 5;\n            this.canvasCtx.strokeStyle = 'gray';\n            this.canvasCtx.beginPath();\n\n            var slicewaveWidth = width / this.bufferLength;\n            var x = 0;\n\n            for (var i = 0; i < this.bufferLength; i++) {\n                var v = this.analyserData[i] / 128.0;\n                var y = v * this.waveHeight;\n\n                if (i === 0) {\n                    this.canvasCtx.moveTo(x, y);\n                } else {\n                    this.canvasCtx.lineTo(x, y);\n                }\n                x += slicewaveWidth;\n            }\n\n            this.canvasCtx.lineTo(width, this.waveHeight);\n            this.canvasCtx.stroke();\n\n        },\n\n        onstart: function () {\n            log.debug('started');\n        },\n        onerror: function () {\n            log.debug('error');\n        },\n        onend: function () {\n            log.debug('end');\n        },\n        onfinalspeechcapture: function (speechtext) {\n            log.debug(speechtext);\n        },\n        oninterimspeechcapture: function (speechtext) {\n            // log.debug(speechtext);\n        }\n\n    };//end of returned object\n});//total end\n"],"names":["define","$","log","wavencoder","debug","recognition","recognizing","final_transcript","interim_transcript","start_timestamp","lang","interval","browsertype","audioContext","processor","microphone","encoder","listener","wavconfig","bufferLen","numChannels","desiredSampleRate","mimeType","clone","extend","this","will_work_ok","opts","window","self","top","is_mobileapp","navigator","userAgent","indexOf","brave","toLowerCase","has_chrome","has_safari","is_ios","hasspeechrec","init","waveheight","uniqueid","SpeechRecognition","webkitSpeechRecognition","is_android","continuous","interimResults","waveHeight","prepare_html","register_events","AudioContext","webkitAudioContext","onStop","canvas","canvasCtx","getContext","set_grammar","grammar","SpeechGrammarList","webkitSpeechGrammarList","speechRecognitionList","addFromString","grammars","start","that","Date","now","onstart","sampleRate","createScriptProcessor","connect","destination","mediaDevices","getUserMedia","audio","video","then","stream","state","resume","tracks","getTracks","createMediaStreamSource","onaudioprocess","event","thebuffers","getBuffers","audioprocess","createAnalyser","fftSize","bufferLength","frequencyBinCount","analyserData","Uint8Array","setInterval","drawWave","forEach","track","stop","catch","error","onerror","clearInterval","close","disconnect","finish","clearRect","width","setTimeout","onfinalspeechcapture","onend","timeStamp","name","onresult","i","resultIndex","results","length","isFinal","transcript","provisional_transcript","oninterimspeechcapture","buffers","ch","inputBuffer","getChannelData","getByteTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","slicewaveWidth","x","y","moveTo","lineTo","stroke","speechtext"],"mappings":"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"}