{"version":3,"file":"translate.min.js","sources":["../src/translate.js"],"sourcesContent":["define(['jquery', 'core/log'], function ($, log) {\n    \"use strict\";\n\n    return {\n\n        session: null,\n        sourceLang: null,\n        destLang: null,\n\n        /**\n         * Check if translation is available and get availability status.\n         * \n         * @param {string} sourceLang Source language code\n         * @param {string} destLang Destination language code\n         * @returns {Promise<string>} 'ready', 'download_needed', or 'unavailable'\n         */\n        check_availability: async function (sourceLang, destLang) {\n            if (!this.is_chrome()) {\n                return 'unavailable';\n            }\n            try {\n                if ('Translator' in window) {\n                    const availability = await window.Translator.availability({\n                        sourceLanguage: sourceLang,\n                        targetLanguage: destLang,\n                    });\n\n                    switch (availability) {\n                        case 'available':\n                            return 'ready';\n                        case 'downloadable':\n                        case 'downloading':\n                            return 'download_needed';\n                        case 'unavailable':\n                        default:\n                            return 'unavailable';\n                    }\n                }\n            } catch (e) {\n                log.error('Availability check failed: ' + e.message);\n            }\n            return 'unavailable';\n        },\n\n        /**\n         * Create translation session. MUST be called from user gesture if download needed.\n         * \n         * @param {string} sourceLang Source language code\n         * @param {string} destLang Destination language code\n         * @returns {Promise<boolean>} True if session created successfully\n         */\n        create_session: async function (sourceLang, destLang, progressCallback) {\n            try {\n                log.debug('Creating translator session: ' + sourceLang + ' -> ' + destLang);\n                log.debug('About to call window.Translator.create()...');\n\n                // Create a timeout promise\n                const timeoutPromise = new Promise((resolve, reject) => {\n                    setTimeout(() => {\n                        reject(new Error('Session creation timed out after 120 seconds'));\n                    }, 120000);\n                });\n\n                // Create a promise that resolves when the session is created\n                const createPromise = window.Translator.create({\n                    sourceLanguage: sourceLang,\n                    targetLanguage: destLang,\n                    monitor: (m) => {\n                        log.debug('Monitor callback invoked');\n                        m.addEventListener(\"downloadprogress\", (event) => {\n                            const percent = ((event.loaded / event.total) * 100).toFixed(1);\n                            log.debug('Download progress: ' + percent + '% (' + event.loaded + '/' + event.total + ')');\n                            // If progress callback is set and is a function, call it with the % progress\n                            if (progressCallback && typeof progressCallback === 'function') {\n                                progressCallback(percent);\n                            }\n                            if (event.loaded === event.total) {\n                                log.debug('Download complete! Waiting for create() to resolve...');\n                            }\n                        });\n                    }\n                });\n\n                log.debug('Waiting for translator creation or timeout...');\n                this.session = await Promise.race([createPromise, timeoutPromise]);\n\n                log.debug('Promise resolved! Setting session properties...');\n                this.sourceLang = sourceLang;\n                this.destLang = destLang;\n                log.debug('Session created successfully');\n                return true;\n            } catch (e) {\n                log.error('Session creation failed: ' + e.message);\n                log.error('Error details: ' + JSON.stringify(e));\n                return false;\n            }\n        },\n\n        /**\n         * Translate text using the browser's native translation API.\n         * \n         * @param {string} text The text to translate.\n         * @returns {Promise<string|boolean>} The translated text or false if failed.\n         */\n        translate: async function (text) {\n            if (!text) {\n                log.debug('no text to translate');\n                return false;\n            }\n\n            try {\n                log.debug('translating : ' + text);\n                var translated = await this.session.translate(text);\n                log.debug(translated);\n                log.debug('translated : ' + translated);\n                return translated;\n\n            } catch (e) {\n                log.error('Native translation failed: ' + e.message);\n            }\n\n            return false;\n        },\n\n        is_chrome: function () {\n            var isChromium = window.chrome;\n            var winNav = window.navigator;\n            var vendorName = winNav.vendor;\n            var isOpera = typeof window.opr !== \"undefined\";\n            var isIEedge = winNav.userAgent.indexOf(\"Edg\") > -1;\n            var isIOSChrome = winNav.userAgent.match(\"CriOS\");\n\n            if (isIOSChrome) {\n                return true;\n            } else if (\n                isChromium !== null &&\n                typeof isChromium !== \"undefined\" &&\n                vendorName === \"Google Inc.\" &&\n                isOpera === false &&\n                isIEedge === false\n            ) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    };\n});\n"],"names":["define","$","log","session","sourceLang","destLang","check_availability","async","this","is_chrome","window","Translator","availability","sourceLanguage","targetLanguage","e","error","message","create_session","progressCallback","debug","timeoutPromise","Promise","resolve","reject","setTimeout","Error","createPromise","create","monitor","m","addEventListener","event","percent","loaded","total","toFixed","race","JSON","stringify","translate","text","translated","isChromium","chrome","winNav","navigator","vendorName","vendor","isOpera","opr","isIEedge","userAgent","indexOf","match"],"mappings":"AAAAA,kCAAO,CAAC,SAAU,aAAa,SAAUC,EAAGC,WAGjC,CAEHC,QAAS,KACTC,WAAY,KACZC,SAAU,KASVC,mBAAoBC,eAAgBH,WAAYC,cACvCG,KAAKC,kBACC,qBAGH,eAAgBC,OAAQ,cACGA,OAAOC,WAAWC,aAAa,CACtDC,eAAgBT,WAChBU,eAAgBT,gBAIX,kBACM,YACN,mBACA,oBACM,gCAGA,gBAGrB,MAAOU,GACLb,IAAIc,MAAM,8BAAgCD,EAAEE,eAEzC,eAUXC,eAAgBX,eAAgBH,WAAYC,SAAUc,sBAE9CjB,IAAIkB,MAAM,gCAAkChB,WAAa,OAASC,UAClEH,IAAIkB,MAAM,qDAGJC,eAAiB,IAAIC,SAAQ,CAACC,QAASC,UACzCC,YAAW,KACPD,OAAO,IAAIE,MAAM,mDAClB,SAIDC,cAAgBjB,OAAOC,WAAWiB,OAAO,CAC3Cf,eAAgBT,WAChBU,eAAgBT,SAChBwB,QAAUC,IACN5B,IAAIkB,MAAM,4BACVU,EAAEC,iBAAiB,oBAAqBC,cAC9BC,SAAYD,MAAME,OAASF,MAAMG,MAAS,KAAKC,QAAQ,GAC7DlC,IAAIkB,MAAM,sBAAwBa,QAAU,MAAQD,MAAME,OAAS,IAAMF,MAAMG,MAAQ,KAEnFhB,kBAAgD,mBAArBA,kBAC3BA,iBAAiBc,SAEjBD,MAAME,SAAWF,MAAMG,OACvBjC,IAAIkB,MAAM,sEAM1BlB,IAAIkB,MAAM,sDACLjB,cAAgBmB,QAAQe,KAAK,CAACV,cAAeN,iBAElDnB,IAAIkB,MAAM,wDACLhB,WAAaA,gBACbC,SAAWA,SAChBH,IAAIkB,MAAM,iCACH,EACT,MAAOL,UACLb,IAAIc,MAAM,4BAA8BD,EAAEE,SAC1Cf,IAAIc,MAAM,kBAAoBsB,KAAKC,UAAUxB,KACtC,IAUfyB,UAAWjC,eAAgBkC,UAClBA,YACDvC,IAAIkB,MAAM,yBACH,MAIPlB,IAAIkB,MAAM,iBAAmBqB,UACzBC,iBAAmBlC,KAAKL,QAAQqC,UAAUC,aAC9CvC,IAAIkB,MAAMsB,YACVxC,IAAIkB,MAAM,gBAAkBsB,YACrBA,WAET,MAAO3B,GACLb,IAAIc,MAAM,8BAAgCD,EAAEE,gBAGzC,GAGXR,UAAW,eACHkC,WAAajC,OAAOkC,OACpBC,OAASnC,OAAOoC,UAChBC,WAAaF,OAAOG,OACpBC,aAAgC,IAAfvC,OAAOwC,IACxBC,SAAWN,OAAOO,UAAUC,QAAQ,QAAU,UAChCR,OAAOO,UAAUE,MAAM,UAKrCX,MAAAA,YAEe,gBAAfI,aACY,IAAZE,UACa,IAAbE"}