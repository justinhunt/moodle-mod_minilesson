{"version":3,"file":"ttazure.min.js","sources":["../src/ttazure.js"],"sourcesContent":["define(['jquery', 'core/log'], function ($, log) {\n    \"use strict\"; // jshint ;_;\n    /*\n    This file is the streamer to azure\n     */\n\n    log.debug('TT Azure Streamer initialising');\n\n    return {\n\n        speechtoken: null,\n        socket: null,\n        audiohelper: null,\n        earlyaudio: [],\n        partials: [],\n        finals: [],\n        ready: false,\n        finaltext: '',\n        region: 'westeurope',\n        apidomain: 'microsoft.com',\n        lang: 'en-US',\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        init: function (speechtoken, theaudiohelper) {\n            this.speechtoken = speechtoken;\n            this.audiohelper = theaudiohelper;\n            this.lang = theaudiohelper.therecorder.lang;\n            this.sentHeader = false; // Track if WAV header was sent\n            switch (theaudiohelper.region) {\n                case 'capetown':\n                    this.region = 'southafricanorth';\n                    this.apidomain = 'microsoft.com';\n                    break;\n\n                case 'ningxia':\n                    this.region = 'chinaeast2';\n                    this.apidomain = 'azure.cn';\n                    break;\n\n                case 'beijing':\n                    this.region = 'chinanorth2';\n                    this.apidomain = 'azure.cn';\n                    break;\n\n                case 'bahrain':\n                case 'dublin':\n                case 'frankfurt':\n                case 'london':\n                case 'westeurope':    \n                    this.region = 'westeurope';\n                    this.apidomain = 'microsoft.com';\n                    break;\n\n                case 'tokyo':\n                case 'useast1':\n                case 'ottawa':\n                case 'saopaulo':\n                case 'singapore':\n                case 'mumbai':\n                case 'sydney':\n                case 'eastus':\n                default:\n                    this.region = 'eastus';\n                    this.apidomain = 'microsoft.com';\n                    break;\n            }\n           \n            this.preparesocket();\n        },\n\n        preparesocket: async function () {\n            var that = this;\n            var url = `wss://${this.region}.stt.speech.${this.apidomain}/speech/recognition/conversation/cognitiveservices/v1?language=${this.lang}`;\n            url += `&format=simple`;\n            // Using the token as a query param is the only easy way without headers\n            url += `&Authorization=Bearer ${this.speechtoken}`;\n\n            this.socket = new WebSocket(url);\n\n            log.debug('TT Azure Streamer socket prepared');\n\n            this.socket.binaryType = 'arraybuffer'; // Important for receiving binary if needed, though we get text mostly\n\n            // Generate a request ID for this session if not already set\n            if (!this.requestId) {\n                this.requestId = this.getUuid();\n            }\n\n            this.socket.onmessage = function (message) {\n                if (typeof message.data === 'string') {\n                    try {\n                        // 1. Find the start of the JSON body (after the headers)\n                        const bodyStartIndex = message.data.indexOf('{');\n                        if (bodyStartIndex === -1) return; // Not a JSON message (e.g., turn.start)\n\n                        // 2. Extract headers to check the Path\n                        const headerSection = message.data.substring(0, bodyStartIndex);\n                        const bodySection = message.data.substring(bodyStartIndex);\n\n                        // 3. Parse the JSON body\n                        const res = JSON.parse(bodySection);\n\n                        // 4. Determine the Path from the header section\n                        if (headerSection.includes('Path:speech.hypothesis')) {\n                            let msg = res.Text;\n                            that.audiohelper.oninterimspeechcapture(that.finaltext + ' ' + msg);\n                        }\n                        else if (headerSection.includes('Path:speech.phrase')) {\n                            if (res.RecognitionStatus === 'Success') {\n                                let msg = res.DisplayText;\n                                that.finaltext += ' ' + msg;\n                                that.audiohelper.oninterimspeechcapture(that.finaltext);\n                                console.debug('Azure final: ' + msg);\n                            }\n                        }\n                    } catch (e) {\n                        console.error(\"Error parsing Azure message:\", e);\n                    }\n                }\n            };\n\n            this.socket.onopen = (event) => {\n                log.debug('TT Azure Streamer socket opened');\n                that.ready = true;\n                that.sentHeader = false; // Reset on new connection\n                that.audiohelper.onSocketReady('fromsocketopen');\n            };\n\n            this.socket.onerror = (event) => {\n                log.debug(event);\n                that.socket.close();\n            };\n\n            this.socket.onclose = (event) => {\n                log.debug(event);\n                that.socket = null;\n                that.requestId = null; // Clear request ID on close so a new one is generated for next session\n            };\n        },\n\n        updatetoken: function (newtoken) {\n            var that = this;\n            if (that.socket) {\n                that.socket.close();\n            }\n            that.speechtoken = newtoken;\n            that.preparesocket();\n        },\n\n        audioprocess: function (stereodata) {\n            var that = this;\n            const base64data = this.binarytobase64(stereodata[0]);\n\n            if (this.ready === undefined || !this.ready) {\n                this.earlyaudio.push(base64data);\n            } else {\n                // If we have early audio, send it first\n                if (this.earlyaudio.length > 0) {\n                    // Send WAV header with first chunk if not sent\n                    if (!this.sentHeader) {\n                        this.sendWavHeader();\n                    }\n                    for (var i = 0; i < this.earlyaudio.length; i++) {\n                        this.sendaudio(this.earlyaudio[i]);\n                    }\n                    this.earlyaudio = [];\n                }\n\n                // Send current chunk\n                if (!this.sentHeader) {\n                    this.sendWavHeader();\n                }\n                this.sendaudio(base64data);\n            }\n        },\n\n        binarytobase64: function (monoaudiodata) {\n            var tempbuffer = []\n            for (let i = 0; i < monoaudiodata.length; i++) {\n                const sample = Math.max(-1, Math.min(1, monoaudiodata[i]))\n                const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7fff\n                tempbuffer.push(intSample & 0xff)\n                tempbuffer.push((intSample >> 8) & 0xff)\n            }\n            // Return Unit8Array\n            return new Uint8Array(tempbuffer);\n        },\n\n        sendWavHeader: function () {\n            // Send a valid WAV header for 16kHz, 16bit, Mono\n            // We use a large size or max size for data chunk\n            var buffer = new ArrayBuffer(44);\n            var view = new DataView(buffer);\n            var sampleRate = 16000;\n            var numChannels = 1;\n\n            /* RIFF identifier */\n            this.writeString(view, 0, 'RIFF');\n            /* file length */\n            view.setUint32(4, 2147483647, true); // Use max int? usually file size - 8. \n            /* RIFF type */\n            this.writeString(view, 8, 'WAVE');\n            /* format chunk identifier */\n            this.writeString(view, 12, 'fmt ');\n            /* format chunk length */\n            view.setUint32(16, 16, true);\n            /* sample format (raw) */\n            view.setUint16(20, 1, true);\n            /* channel count */\n            view.setUint16(22, numChannels, true);\n            /* sample rate */\n            view.setUint32(24, sampleRate, true);\n            /* byte rate (sample rate * block align) */\n            view.setUint32(28, sampleRate * 2, true);\n            /* block align (channel count * bytes per sample) */\n            view.setUint16(32, 2, true);\n            /* bits per sample */\n            view.setUint16(34, 16, true);\n            /* data chunk identifier */\n            this.writeString(view, 36, 'data');\n            /* data chunk length */\n            view.setUint32(40, 2147483647, true);\n\n            var headerBytes = new Uint8Array(buffer);\n            this.sendaudio(headerBytes);\n            this.sentHeader = true;\n        },\n\n        writeString: function (view, offset, string) {\n            for (var i = 0; i < string.length; i++) {\n                view.setUint8(offset + i, string.charCodeAt(i));\n            }\n        },\n\n        getUuid: function () {\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n                return v.toString(16);\n            });\n        },\n\n        createBinaryMessage: function (data) {\n            // Use the session request ID\n            var requestId = this.requestId ? this.requestId : this.getUuid();\n            var headers = [\n                \"Path: audio\",\n                \"X-RequestId: \" + requestId,\n                \"X-Timestamp: \" + new Date().toISOString(),\n                \"Content-Type: audio/x-wav\"\n            ].join(\"\\r\\n\"); // Headers end with \\r\\n\n\n            var headerBytes = new TextEncoder().encode(headers);\n            var headerLen = headerBytes.length;\n\n            var msg = new Uint8Array(2 + headerLen + data.length);\n            // Big Endian 16-bit length\n            msg[0] = (headerLen >> 8) & 0xFF;\n            msg[1] = headerLen & 0xFF;\n            msg.set(headerBytes, 2);\n            msg.set(data, 2 + headerLen);\n            return msg;\n        },\n\n        sendaudio: function (data) {\n            var that = this;\n            if (that.socket && that.socket.readyState === WebSocket.OPEN) {\n                var binaryMsg = this.createBinaryMessage(data);\n                that.socket.send(binaryMsg);\n            }\n        },\n\n        finish: function (mimeType) {\n            // Azure auto-detects silence usually, but we can close.\n            if (this.socket) {\n                // Maybe send end of stream?\n            }\n            var that = this;\n            setTimeout(function () {\n                that.audiohelper.onfinalspeechcapture(that.finaltext);\n                that.cleanup();\n            }, 1000);\n        },\n\n        cancel: function () {\n            this.ready = false;\n            this.earlyaudio = [];\n            this.finaltext = '';\n            if (this.socket) {\n                this.socket.close();\n            }\n        },\n\n        cleanup: function () {\n            this.cancel();\n        }\n\n    };\n\n});\n"],"names":["define","$","log","debug","speechtoken","socket","audiohelper","earlyaudio","partials","finals","ready","finaltext","region","apidomain","lang","clone","extend","this","init","theaudiohelper","therecorder","sentHeader","preparesocket","async","that","url","WebSocket","binaryType","requestId","getUuid","onmessage","message","data","bodyStartIndex","indexOf","headerSection","substring","bodySection","res","JSON","parse","includes","msg","Text","oninterimspeechcapture","RecognitionStatus","DisplayText","console","e","error","onopen","event","onSocketReady","onerror","close","onclose","updatetoken","newtoken","audioprocess","stereodata","base64data","binarytobase64","undefined","length","sendWavHeader","i","sendaudio","push","monoaudiodata","tempbuffer","sample","Math","max","min","intSample","Uint8Array","buffer","ArrayBuffer","view","DataView","writeString","setUint32","setUint16","sampleRate","headerBytes","offset","string","setUint8","charCodeAt","replace","c","r","random","toString","createBinaryMessage","headers","Date","toISOString","join","TextEncoder","encode","headerLen","set","readyState","OPEN","binaryMsg","send","finish","mimeType","setTimeout","onfinalspeechcapture","cleanup","cancel"],"mappings":"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"}