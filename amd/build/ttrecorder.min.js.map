{"version":3,"file":"ttrecorder.min.js","sources":["../src/ttrecorder.js"],"sourcesContent":["define(\n    ['jquery', 'core/log', 'core/notification', 'core/ajax', 'mod_minilesson/ttaudiohelper', 'mod_minilesson/ttbrowserrec',\n    'core/str', 'mod_minilesson/timer', 'mod_minilesson/ttmsspeech', 'mod_minilesson/mediauploader'],\n    function ($, log, notification, ajax, audioHelper, browserRec, str, timer, msspeech, mediauploader) {\n        \"use strict\"; // jshint ;_;\n        /*\n        *  The TT recorder\n         */\n\n        log.debug('TT Recorder: initialising');\n\n        return {\n            waveHeight: 75,\n            audio: {\n                stream: null,\n                blob: null,\n                dataURI: null,\n                start: null,\n                end: null,\n                isRecording: false,\n                isRecognizing: false,\n                isWaiting: false,\n                transcript: null\n            },\n            submitting: false,\n            owner: '',\n            controls: {},\n            uniqueid: null,\n            audio_updated: null,\n            maxtime: 0,\n            passagehash: null,\n            region: null,\n            asrurl: null,\n            lang: null,\n            browserrec: null,\n            usebrowserrec: false,\n            currentTime: 0,\n            stt_guided: false,\n            currentPrompt: false,\n            speechtoken: '',\n            speechtokenregion: '',\n            speechtokenvalidseconds: '',\n            speechtokentype: '',\n            forcestreaming: false,\n            is_streaming: false,\n            using_msspeech: false,\n            msspeech_instance: null,\n            savemedia: false,\n            uploader: null,\n            strings: {},\n\n            //for making multiple instances\n            clone: function () {\n                return $.extend(true, {}, this);\n            },\n\n            init: function (opts) {\n\n                var that = this;\n                this.uniqueid = opts['uniqueid'];\n                this.callback = opts['callback'];\n                this.stt_guided = opts['stt_guided'] ? opts['stt_guided'] : false;\n                this.init_strings();\n                this.prepare_html();\n                this.controls.recordercontainer.show();\n                this.register_events();\n\n                //init media uploader\n                log.debug('ttr uploader savemedia: ' + this.savemedia);\n                if (this.savemedia) {\n                    log.debug('ttr uploader creating: ');\n                    that.uploader = mediauploader.clone();\n                    var uconfig = {};\n                    uconfig.wstoken = that.wstoken;\n                    uconfig.moodlewsrestformat = \"\";\n                    uconfig.mediatype = that.mediatype;\n                    uconfig.parent = that.wwwroot;\n                    uconfig.appid = that.appid;\n                    uconfig.owner = that.owner;\n                    uconfig.region = that.savemediaregion;\n                    uconfig.expiredays = that.expiredays;\n                    uconfig.transcode = that.transcode ? 1 : 0;\n                    uconfig.cloudpoodllurl = that.cloudpoodllurl;\n                    uconfig.transcoder = \"default\";\n                    uconfig.transcribe = 0;\n                    uconfig.subtitle = 0;\n                    uconfig.language = that.lang;\n                    uconfig.transcribevocab = \"none\";\n                    uconfig.notificationurl = \"none\";\n                    that.uploader.init(uconfig);\n                }\n\n                //token check\n                this.using_msspeech = this.can_msspeech();\n                if (this.using_msspeech) {\n                    var referencetext = opts['referencetext'];\n                    this.msspeech_instance = msspeech.clone();\n                    this.msspeech_instance.init(this.speechtoken, this.speechtokenregion, this.lang, referencetext);\n                }\n\n                // Callback: Timer updates.\n                var handle_timer_update = function () {\n                    var displaytime = that.timer.fetch_display_time();\n                    that.controls.timerstatus.html(displaytime);\n                    log.debug('timer_seconds: ' + that.timer.seconds);\n                    log.debug('displaytime: ' + displaytime);\n                    if (that.timer.seconds == 0 && that.timer.initseconds > 0) {\n                        that.update_audio('isRecognizing', true);\n                        if (that.usebrowserrec) {\n                            that.browserrec.stop();\n                        } else {\n                            that.audiohelper.stop();\n                        }\n                    }\n                };\n\n                // Callback: Recorder device errors.\n                var on_error = function (error) {\n                    switch (error.name) {\n                        case 'PermissionDeniedError':\n                        case 'NotAllowedError':\n                            notification.alert(\"Error\", that.strings.allowmicaccess, \"OK\");\n                            break;\n                        case 'DevicesNotFoundError':\n                        case 'NotFoundError':\n                            notification.alert(\"Error\", that.strings.nomicdetected, \"OK\");\n                            break;\n                        default:\n                            //other errors, like from Edge can fire repeatedly so a notification is not a good idea\n                            //notification.alert(\"Error\", error.name, \"OK\");\n                            log.debug(\"Error\", error.name);\n                    }\n                };\n\n                // Callback: Recording stopped.\n                var on_stopped = function (blob) {\n                    that.timer.stop()\n\n                    //if the blob is undefined then the user is super clicking or something\n                    if (blob === undefined) {\n                        return;\n                    }\n\n                    //Update our current audio object\n                    var newaudio = {\n                        blob: blob,\n                        dataURI: URL.createObjectURL(blob),\n                        end: new Date(),\n                        isRecording: false,\n                        length: Math.round((that.audio.end - that.audio.start) / 1000),\n                    };\n                    that.update_audio(newaudio);\n\n                    // If we have a blob and we need to upload it, do so\n                    if (that.savemedia) {\n                        that.uploader.uploadBlob(that.audio.blob, 'audio/wav');\n                        var message = {};\n                        message.type = 'mediasaved';\n                        message.mediaurl = that.uploader.config.s3root + that.uploader.config.s3filename;\n                        message.bloburl = newaudio.dataURI;\n                        log.debug('ttr uploader: callback mediasaved');\n                        log.debug(message);\n                        that.callback(message);\n                    }\n\n                    //  If we are browser rec, we should exit here\n                    if (that.usebrowserrec) {\n                        return;\n                    }\n\n                    //if we are not streaming then upload_transcribe (ie send to poodll servers)\n                    if (!that.is_streaming) {\n                        if (that.using_msspeech) {\n                            that.do_msspeech(that.audio.blob, function (response) {\n                                that.gotMSResults(response);\n                                that.update_audio('isRecognizing', false);\n                            });\n                        } else {\n                            that.upload_transcribe(that.audio.blob, function (response) {\n                                log.debug(response);\n                                if (response.data.result === \"success\" && response.data.transcript) {\n                                    that.gotRecognition(response.data.transcript.trim());\n                                } else {\n                                    notification.alert(\"Information\", that.strings.speechnotrecognized, \"OK\");\n                                }\n                                that.update_audio('isRecognizing', false);\n                            });\n                        }\n                    }\n\n                };\n\n                // Callback: Recorder device got stream - start recording\n                var on_gotstream = function (stream) {\n                    var newaudio = { stream: stream, isRecording: true, isWaiting: false };\n                    that.update_audio(newaudio);\n                };\n\n                //If browser rec (Chrome Speech Rec)\n                if (browserRec.will_work_ok() && !this.stt_guided && !this.forcestreaming && !this.using_msspeech) {\n                    //Init browserrec\n                    log.debug(\"using browser rec\");\n                    this.browserrec = browserRec.clone();\n                    this.browserrec.init(this.lang, this.waveHeight, this.uniqueid);\n                    this.usebrowserrec = true;\n\n                    //set up events\n                    that.browserrec.onerror = on_error;\n                    that.browserrec.onStop = on_stopped;\n                    that.browserrec.onend = function () {\n                        //do something here\n                    };\n                    that.browserrec.onstart = function () {\n                        //do something here\n                    };\n                    that.browserrec.onfinalspeechcapture = function (speechtext) {\n                        that.gotRecognition(speechtext);\n                        that.update_audio('isRecording', false);\n                        that.update_audio('isRecognizing', false);\n                    };\n\n                    that.browserrec.oninterimspeechcapture = function (speechtext) {\n                        that.gotInterimRecognition(speechtext);\n                    };\n\n\n                    //If we have a streaming token\n                } else if (this.can_stream() && !this.stt_guided) {\n                    this.is_streaming = true;\n                    //Init streaming audio helper\n                    log.debug(\"using audio helper and streaming rec\");\n                    this.audiohelper = audioHelper.clone();\n                    this.audiohelper.init(this.waveHeight, this.uniqueid, this);\n\n                    that.audiohelper.onError = on_error;\n                    that.audiohelper.onStop = on_stopped;\n                    that.audiohelper.onStream = on_gotstream;\n                    that.audiohelper.onfinalspeechcapture = function (speechtext) {\n                        that.gotRecognition(speechtext);\n                        that.update_audio('isRecording', false);\n                        that.update_audio('isRecognizing', false);\n                    };\n                    that.audiohelper.oninterimspeechcapture = function (speechtext) {\n                        that.gotInterimRecognition(speechtext);\n                    };\n\n                    //If upload_transcriber\n                } else {\n                    //set up upload_transcriber\n                    log.debug(\"using upload_transcriber\");\n                    this.audiohelper = audioHelper.clone();\n                    this.audiohelper.init(this.waveHeight, this.uniqueid, this);\n\n                    that.audiohelper.onError = on_error;\n                    that.audiohelper.onStop = on_stopped;\n                    that.audiohelper.onStream = on_gotstream;\n                }//end of setting up recorders\n\n                // Set up token refresh\n                log.debug('original speechtoken - ' + this.speechtoken);\n                log.debug('original speechtokenregion - ' + this.speechtokenregion);\n                log.debug('speechtokentype - ' + this.speechtokentype);\n                log.debug('speechtokenvalidseconds - ' + this.speechtokenvalidseconds);\n                this.init_token_refresh();\n\n                // Setting up timer.\n                this.timer = timer.clone();\n                this.timer.init(this.maxtime, handle_timer_update);\n                // Init the timer readout\n                handle_timer_update();\n            },\n\n            can_stream: function () {\n                return (this.speechtoken && this.speechtoken !== 'false'\n                    && (this.speechtokentype === 'assemblyai' || this.speechtokentype === 'azure')\n                    && !this.stt_guided);\n            },\n\n            can_msspeech: function () {\n                return (this.speechtoken && this.speechtoken !== 'false' && this.speechtokentype === 'msspeech');\n            },\n\n            update_currentprompt: function (targettext) {\n                this.currentPrompt = targettext;\n                if (this.using_msspeech) {\n                    this.msspeech_instance.set_reference_text(targettext);\n                }\n            },\n\n            blobToArrayBuffer: function (blob) {\n                return new Promise((resolve, reject) => {\n                    const reader = new FileReader();\n                    reader.onload = function (event) {\n                        resolve(event.target.result);\n                    };\n                    reader.onerror = function (error) {\n                        reject(error);\n                    };\n                    reader.readAsArrayBuffer(blob);\n                });\n            },\n\n            init_strings: function () {\n                var that = this;\n                str.get_strings([\n                    { \"key\": \"allowmicaccess\", \"component\": 'mod_minilesson' },\n                    { \"key\": \"nomicdetected\", \"component\": 'mod_minilesson' },\n                    { \"key\": \"speechnotrecognized\", \"component\": 'mod_minilesson' },\n\n                ]).done(function (s) {\n                    var i = 0;\n                    that.strings.allowmicaccess = s[i++];\n                    that.strings.nomicdetected = s[i++];\n                    that.strings.speechnotrecognized = s[i++];\n                });\n            },\n\n            prepare_html: function () {\n                this.controls.recordercontainer = $('#ttrec_container_' + this.uniqueid);\n                this.controls.recorderbutton = $('#' + this.uniqueid + '_recorderdiv');\n                this.controls.waveform = $('#' + this.uniqueid + '_waveform');\n                this.controls.timerstatus = $('.timerstatus_' + this.uniqueid);\n                this.passagehash = this.controls.recorderbutton.data('passagehash');\n                this.region = this.controls.recorderbutton.data('region');\n                this.lang = this.controls.recorderbutton.data('lang');\n                this.asrurl = this.controls.recorderbutton.data('asrurl');\n                this.speechtoken = this.controls.recorderbutton.data('speechtoken');\n                this.speechtokenregion = this.controls.recorderbutton.data('speechtokenregion');\n                this.speechtokenvalidseconds = this.controls.recorderbutton.data('speechtokenvalidseconds');\n                this.speechtokentype = this.controls.recorderbutton.data('speechtokentype');\n                this.forcestreaming = this.controls.recorderbutton.data('forcestreaming');\n                this.maxtime = this.controls.recorderbutton.data('maxtime');\n                this.waveHeight = this.controls.recorderbutton.data('waveheight');\n                // Whether to save media and related\n                this.savemedia = this.controls.recorderbutton.data('savemedia') === 1;\n                this.savemediaregion = this.controls.recorderbutton.data('savemediaregion');\n                this.wstoken = this.controls.recorderbutton.data('wstoken');\n                this.wwwroot = this.controls.recorderbutton.data('wwwroot');\n                this.appid = this.controls.recorderbutton.data('appid');\n                this.owner = this.controls.recorderbutton.data('owner');\n                this.transcode = this.controls.recorderbutton.data('transcode') === 1;\n                this.expiredays = this.controls.recorderbutton.data('expiredays');\n                this.mediatype = this.controls.recorderbutton.data('mediatype');\n                this.cloudpoodllurl = this.controls.recorderbutton.data('cloudpoodllurl');\n\n            },\n\n            init_token_refresh: function () {\n                var that = this;\n                var validsecs = Number(that.speechtokenvalidseconds) || 0;\n                // If we have a token, then we can set up a timer to refresh it\n                if (that.speechtoken && validsecs > 0) {\n                    //(valid until seconds - now seconds) => milliseconds\n                    var refreshInterval = validsecs * 1000;\n                    log.debug('Refreshing ' + that.speechtokentype + ' token after ' + refreshInterval + ' milliseconds');\n                    if (refreshInterval > 0) {\n                        setTimeout(function () {\n                            // Refresh the token\n                            log.debug('Refreshing streaming token...');\n                            var ajaxresult = ajax.call([{\n                                methodname: 'mod_minilesson_refresh_token',\n                                args: {\n                                    'type': that.speechtokentype,\n                                    'region': that.region\n                                },\n                                async: false\n                            }])[0].then(ajaxresult => {\n                                log.debug('New token ajaxresult:', ajaxresult);\n                                var newtoken = JSON.parse(ajaxresult);\n                                log.debug('New token received:', newtoken);\n                                // Update our internal token\n                                if (newtoken && newtoken.token) {\n                                    that.speechtoken = newtoken.token;\n                                    that.speechtokenvalidseconds = newtoken.validseconds;\n                                    switch (that.speechtokentype) {\n                                        case 'assemblyai':\n                                        case 'azure':\n                                            if (that.audiohelper && that.audiohelper.streamer) {\n                                                that.audiohelper.streamer.updatetoken(newtoken.token);\n                                            }\n                                            break;\n                                        case 'msspeech':\n                                            that.msspeech_instance.updatetoken(newtoken.token);\n                                            break;\n                                    }\n                                    log.debug('Streaming token refreshed successfully.');\n                                    // Start the countdown all over again\n                                    that.init_token_refresh();\n                                } else {\n                                    log.debug('New token was not a token.');\n                                }\n                            });\n\n                        }, refreshInterval);\n                    } else {\n                        log.debug('Refresh interval is 0. Not refreshing token.');\n                    }\n                } else {\n                    log.debug('No valid streaming token available, skipping refresh setup.');\n                }\n            },\n\n            silence_detected: function () {\n                if (this.audio.isRecording) {\n                    this.toggleRecording();\n                }\n            },\n\n            update_audio: function (newprops, val) {\n                if (typeof newprops === 'string') {\n                    log.debug('update_audio:' + newprops + ':' + val);\n                    if (this.audio[newprops] !== val) {\n                        this.audio[newprops] = val;\n                        this.audio_updated();\n                    }\n                } else {\n                    for (var theprop in newprops) {\n                        this.audio[theprop] = newprops[theprop];\n                        log.debug('update_audio:' + theprop + ':' + newprops[theprop]);\n                    }\n                    this.audio_updated();\n                }\n            },\n\n            register_events: function () {\n                var that = this;\n                this.controls.recordercontainer.click(function () {\n                    that.toggleRecording();\n                });\n\n                this.audio_updated = function () {\n                    //pointer\n                    if (that.audio.isRecognizing || that.audio.isWaiting) {\n                        that.show_recorder_pointer('none');\n                    } else {\n                        that.show_recorder_pointer('auto');\n                    }\n                    //the color\n                    //we no longer swap out colors for waiting .. its too fast and a bit jarring\n                    if (that.audio.isRecognizing || that.audio.isWaiting) {\n                        this.controls.recorderbutton.removeClass('ttrec_ready');\n                        this.controls.recorderbutton.removeClass('ttrec_waiting');\n                        this.controls.waveform.removeClass('ttrec_waiting');\n                        this.controls.recorderbutton.removeClass('ttrec_isrecording');\n                        this.controls.recorderbutton.addClass('ttrec_engaged');\n                    } else if (that.audio.isRecording) {\n                        this.controls.recorderbutton.removeClass('ttrec_ready');\n                        this.controls.waveform.removeClass('ttrec_waiting');\n                        this.controls.recorderbutton.removeClass('ttrec_waiting');\n                        this.controls.recorderbutton.removeClass('ttrec_engaged');\n                        this.controls.recorderbutton.addClass('ttrec_isrecording');\n                    } else if (that.audio.isWaiting && false) {\n                        this.controls.recorderbutton.removeClass('ttrec_engaged');\n                        this.controls.recorderbutton.removeClass('ttrec_ready');\n                        this.controls.recorderbutton.removeClass('ttrec_isrecording');\n                        this.controls.recorderbutton.addClass('ttrec_waiting');\n                        this.controls.waveform.addClass('ttrec_waiting');\n                    } else {\n                        this.controls.recorderbutton.removeClass('ttrec_engaged');\n                        this.controls.recorderbutton.removeClass('ttrec_waiting');\n                        this.controls.recorderbutton.removeClass('ttrec_isrecording');\n                        this.controls.waveform.removeClass('ttrec_waiting');\n                        this.controls.recorderbutton.addClass('ttrec_ready');\n                    }\n\n                    //the font awesome spinner/mic/square\n                    that.controls.recorderbutton.html(that.recordBtnContent());\n                };\n\n            },\n\n            show_recorder_pointer: function (show) {\n                if (show) {\n                    this.controls.recorderbutton.css('pointer-events', 'none');\n                } else {\n                    this.controls.recorderbutton.css('pointer-events', 'auto');\n                }\n\n            },\n\n            startedRecording: function () {\n\n                var message = {};\n                message.type = 'recording';\n                message.results = '';\n                this.callback(message);\n            },\n\n            gotMSResults: function (results) {\n                log.debug(results);\n                var message = {};\n                message.type = 'pronunciation_results';\n                message.results = results;\n                this.callback(message);\n            },\n\n            gotRecognition: function (transcript) {\n                log.debug('transcript:' + transcript);\n                if (transcript.trim() == '') {\n                    return; }\n                var message = {};\n                message.type = 'speech';\n                message.capturedspeech = transcript;\n                this.callback(message);\n            },\n\n            gotInterimRecognition: function (transcript) {\n                var message = {};\n                message.type = 'interimspeech';\n                message.capturedspeech = transcript;\n                //POINT\n                this.callback(message);\n            },\n\n            cleanWord: function (word) {\n                return word.replace(/['!\"#$%&\\\\'()\\*+,\\-\\.\\/:;<=>?@\\[\\\\\\]\\^_`{|}~']/g, \"\").toLowerCase();\n            },\n\n            recordBtnContent: function () {\n\n                if (!this.audio.isRecognizing) {\n                    if (this.audio.isRecording) {\n                        return '<i class=\"fa fa-stop\">';\n                    } else if (this.audio.isWaiting) {\n                        return '<i class=\"fa fa-solid fa-cog fa-spin\">';\n                    } else {\n                        return '<i class=\"fa fa-microphone\">';\n                    }\n                } else {\n                    return '<i class=\"fa fa-spinner fa-spin\">';\n                }\n            },\n            toggleRecording: function () {\n                var that = this;\n\n                //If we are recognizing, then we want to discourage super click'ers\n                if (this.audio.isRecognizing || this.audio.isWaiting) {\n                    return;\n                }\n\n                //If we are currently recording\n                if (this.audio.isRecording) {\n                    that.timer.stop();\n\n                    //If using Browser Rec (chrome speech)\n                    if (this.usebrowserrec) {\n                        that.update_audio('isRecording', false);\n                        that.update_audio('isRecognizing', true);\n                        this.browserrec.stop();\n\n                        //If using upload_transcriber or streaming\n                    } else {\n                        this.update_audio('isRecognizing', true);\n                        this.audiohelper.stop();\n                    }\n\n                    //If we are NOT currently recording\n                } else {\n                    // Run the timer\n                    that.currentTime = 0;\n                    that.timer.reset();\n                    that.timer.start();\n\n\n                    //If using Browser Rec (chrome speech)\n                    if (this.usebrowserrec) {\n                        this.update_audio('isRecording', true);\n                        this.browserrec.start();\n\n                        //If using Audio helper for upload_transcriber or streaming\n                    } else {\n                        var newaudio = {\n                            stream: null,\n                            blob: null,\n                            dataURI: null,\n                            start: new Date(),\n                            end: null,\n                            isRecording: false,\n                            isRecognizing: false,\n                            isWaiting: true,\n                            transcript: null\n                        };\n                        this.update_audio(newaudio);\n                        this.audiohelper.start();\n                    }\n                    this.startedRecording();\n                }\n            },\n\n            upload_transcribe: function (blob, callback) {\n                var bodyFormData = new FormData();\n                var blobname = this.uniqueid + Math.floor(Math.random() * 100) + '.wav';\n                bodyFormData.append('audioFile', blob, blobname);\n                bodyFormData.append('scorer', this.passagehash);\n                if (this.stt_guided) {\n                    bodyFormData.append('strictmode', 'false');\n                } else {\n                    bodyFormData.append('strictmode', 'true');\n                }\n                //prompt is used by whisper and other transcibers down the line\n                if (this.currentPrompt !== false) {\n                    bodyFormData.append('prompt', this.currentPrompt);\n                }\n                bodyFormData.append('lang', this.lang);\n                bodyFormData.append('wwwroot', M.cfg.wwwroot);\n\n                var oReq = new XMLHttpRequest();\n                oReq.open(\"POST\", this.asrurl, true);\n                oReq.onUploadProgress = function (progressEvent) { };\n                oReq.onload = function (oEvent) {\n                    if (oReq.status === 200) {\n                        callback(JSON.parse(oReq.response));\n                    } else {\n                        callback({ data: { result: \"error\" } });\n                        log.debug(oReq.error);\n                    }\n                };\n                try {\n                    oReq.send(bodyFormData);\n                } catch (err) {\n                    callback({ data: { result: \"error\" } });\n                    log.debug(err);\n                }\n            },\n\n            do_msspeech: function (blob, callback) {\n                this.msspeech_instance.recognize(blob, callback)\n            },\n\n        };//end of return value\n\n    }\n);"],"names":["define","$","log","notification","ajax","audioHelper","browserRec","str","timer","msspeech","mediauploader","debug","waveHeight","audio","stream","blob","dataURI","start","end","isRecording","isRecognizing","isWaiting","transcript","submitting","owner","controls","uniqueid","audio_updated","maxtime","passagehash","region","asrurl","lang","browserrec","usebrowserrec","currentTime","stt_guided","currentPrompt","speechtoken","speechtokenregion","speechtokenvalidseconds","speechtokentype","forcestreaming","is_streaming","using_msspeech","msspeech_instance","savemedia","uploader","strings","clone","extend","this","init","opts","that","callback","init_strings","prepare_html","recordercontainer","show","register_events","uconfig","wstoken","moodlewsrestformat","mediatype","parent","wwwroot","appid","savemediaregion","expiredays","transcode","cloudpoodllurl","transcoder","transcribe","subtitle","language","transcribevocab","notificationurl","can_msspeech","referencetext","handle_timer_update","displaytime","fetch_display_time","timerstatus","html","seconds","initseconds","update_audio","stop","audiohelper","on_error","error","name","alert","allowmicaccess","nomicdetected","on_stopped","undefined","newaudio","URL","createObjectURL","Date","length","Math","round","uploadBlob","message","mediaurl","config","s3root","s3filename","bloburl","do_msspeech","response","gotMSResults","upload_transcribe","data","result","gotRecognition","trim","speechnotrecognized","on_gotstream","will_work_ok","can_stream","onError","onStop","onStream","onfinalspeechcapture","speechtext","oninterimspeechcapture","gotInterimRecognition","onerror","onend","onstart","init_token_refresh","update_currentprompt","targettext","set_reference_text","blobToArrayBuffer","Promise","resolve","reject","reader","FileReader","onload","event","target","readAsArrayBuffer","get_strings","done","s","i","recorderbutton","waveform","validsecs","Number","refreshInterval","setTimeout","call","methodname","args","async","then","ajaxresult","newtoken","JSON","parse","token","validseconds","streamer","updatetoken","silence_detected","toggleRecording","newprops","val","theprop","click","show_recorder_pointer","removeClass","addClass","recordBtnContent","css","startedRecording","results","capturedspeech","cleanWord","word","replace","toLowerCase","reset","bodyFormData","FormData","blobname","floor","random","append","M","cfg","oReq","XMLHttpRequest","open","onUploadProgress","progressEvent","oEvent","status","send","err","recognize"],"mappings":"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"}