{"version":3,"file":"ttrecorder.min.js","sources":["../src/ttrecorder.js"],"sourcesContent":["define(['jquery', 'core/log','core/notification', 'mod_minilesson/ttaudiohelper','mod_minilesson/ttbrowserrec','core/str','mod_minilesson/timer' ],\n    function ($, log, notification, audioHelper, browserRec,str, timer) {\n    \"use strict\"; // jshint ;_;\n    /*\n    *  The TT recorder\n     */\n\n    log.debug('TT Recorder: initialising');\n\n    return {\n        waveHeight: 75,\n        audio: {\n            stream: null,\n            blob: null,\n            dataURI: null,\n            start: null,\n            end: null,\n            isRecording: false,\n            isRecognizing: false,\n            isWaiting: false,\n            transcript: null\n        },\n        submitting: false,\n        owner: '',\n        controls: {},\n        uniqueid: null,\n        audio_updated: null,\n        maxtime: 0,\n        passagehash: null,\n        region: null,\n        asrurl: null,\n        lang: null,\n        browserrec: null,\n        usebrowserrec: false,\n        currentTime: 0,\n        stt_guided: false,\n        currentPrompt: false,\n        streamingtoken: '',\n        strings: {},\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        init: function(opts){\n\n            var that = this;\n            this.uniqueid=opts['uniqueid'];\n            this.callback=opts['callback'];\n            this.stt_guided = opts['stt_guided'] ? opts['stt_guided'] : false;\n            this.init_strings();\n            this.prepare_html();\n            this.controls.recordercontainer.show();\n            this.register_events();\n\n            // Callbacks.\n\n            // Callback: Timer updates.\n            var handle_timer_update = function(){\n                var displaytime = that.timer.fetch_display_time();\n                that.controls.timerstatus.html(displaytime);\n                log.debug('timer_seconds: ' + that.timer.seconds);\n                log.debug('displaytime: ' + displaytime);\n                if (that.timer.seconds == 0 && that.timer.initseconds > 0) {\n                    that.update_audio('isRecognizing', true);\n                    if(that.usebrowserrec){\n                        that.browserrec.stop();\n                    }else{\n                        that.audiohelper.stop();\n                    }\n                }\n            };\n\n            // Callback: Recorder device errors.\n            var on_error = function(error) {\n                switch (error.name) {\n                    case 'PermissionDeniedError':\n                    case 'NotAllowedError':\n                        notification.alert(\"Error\",that.strings.allowmicaccess, \"OK\");\n                        break;\n                    case 'DevicesNotFoundError':\n                    case 'NotFoundError':\n                        notification.alert(\"Error\",that.strings.nomicdetected, \"OK\");\n                        break;\n                    default:\n                        //other errors, like from Edge can fire repeatedly so a notification is not a good idea\n                        //notification.alert(\"Error\", error.name, \"OK\");\n                        log.debug(\"Error\", error.name);\n                }\n            };\n\n            // Callback: Recording stopped.\n            var on_stopped = function(blob) {\n                that.timer.stop()\n\n                //if the blob is undefined then the user is super clicking or something\n                if(blob===undefined){\n                    return;\n                }\n\n                //if ds recc\n                var newaudio = {\n                    blob: blob,\n                    dataURI: URL.createObjectURL(blob),\n                    end: new Date(),\n                    isRecording: false,\n                    length: Math.round((that.audio.end - that.audio.start) / 1000),\n                };\n                that.update_audio(newaudio);\n\n                //if we are not streaming then deep speech rec\n                if(!that.is_streaming()){\n                    that.deepSpeech2(that.audio.blob, function(response){\n                        log.debug(response);\n                        if(response.data.result===\"success\" && response.data.transcript){\n                            that.gotRecognition(response.data.transcript.trim());\n                        } else {\n                            notification.alert(\"Information\",that.strings.speechnotrecognized, \"OK\");\n                        }\n                        that.update_audio('isRecognizing',false);\n                    });\n                }\n\n            };\n\n            // Callback: Recorder device got stream - start recording\n            var on_gotstream=  function(stream) {\n                var newaudio={stream: stream, isRecording: true};\n                that.update_audio(newaudio);\n\n                //TO DO - conditionally start timer here (not toggle recording)\n                //so a device error does not cause timer disaster\n                // that.timer.reset();\n                // that.timer.start();\n            };\n\n            //If browser rec (Chrome Speech Rec) (and ds is optional)\n            if(browserRec.will_work_ok() && ! this.stt_guided && !this.is_streaming()){\n                //Init browserrec\n                log.debug(\"using browser rec\");\n                this.browserrec = browserRec.clone();\n                this.browserrec.init(this.lang,this.waveHeight,this.uniqueid);\n                this.usebrowserrec=true;\n\n                //set up events\n                that.browserrec.onerror = on_error;\n                that.browserrec.onend = function(){\n                        //do something here\n                };\n                that.browserrec.onstart = function(){\n                    //do something here\n                };\n                that.browserrec.onfinalspeechcapture=function(speechtext){\n                    that.gotRecognition(speechtext);\n                    that.update_audio('isRecording',false);\n                    that.update_audio('isRecognizing',false);\n                };\n\n                that.browserrec.oninterimspeechcapture=function(speechtext){\n                    that.gotInterimRecognition(speechtext);\n                };\n\n            //If we have a streaming token\n            }else if( this.is_streaming() && ! this.stt_guided ) {\n                //Init streaming audio helper\n                log.debug(\"using audio helper and streaming rec\");\n                this.audiohelper =  audioHelper.clone();\n                this.audiohelper.init(this.waveHeight,this.uniqueid, this);\n\n                that.audiohelper.onError = on_error;\n                that.audiohelper.onStop = on_stopped;\n                that.audiohelper.onSocketReady = on_gotstream;\n                that.audiohelper.onfinalspeechcapture = function(speechtext){\n                    that.gotRecognition(speechtext);\n                    that.update_audio('isRecording',false);\n                    that.update_audio('isRecognizing',false);\n                };\n                that.audiohelper.oninterimspeechcapture = function(speechtext){\n                    that.gotInterimRecognition(speechtext);\n                };\n                \n            //If DS rec\n            } else {\n                //set up wav for ds rec\n                log.debug(\"using ds rec\");\n                this.audiohelper =  audioHelper.clone();\n                this.audiohelper.init(this.waveHeight,this.uniqueid,this);\n\n                that.audiohelper.onError = on_error;\n                that.audiohelper.onStop = on_stopped;\n                that.audiohelper.onStream = on_gotstream;\n\n            }//end of setting up recorders\n\n            // Setting up timer.\n            this.timer = timer.clone();\n            this.timer.init(this.maxtime, handle_timer_update);\n            // Init the timer readout\n            handle_timer_update();\n        },\n\n        is_streaming: function( ){\n            return (this.streamingtoken && this.streamingtoken !== 'false' && !this.stt_guided);\n        },\n\n        init_strings: function(){\n            var that=this;\n            str.get_strings([\n                { \"key\": \"allowmicaccess\", \"component\": 'mod_minilesson'},\n                { \"key\": \"nomicdetected\", \"component\": 'mod_minilesson'},\n                { \"key\": \"speechnotrecognized\", \"component\": 'mod_minilesson'},\n\n            ]).done(function (s) {\n                var i = 0;\n                that.strings.allowmicaccess = s[i++];\n                that.strings.nomicdetected = s[i++];\n                that.strings.speechnotrecognized = s[i++];\n            });\n        },\n\n        prepare_html: function(){\n            this.controls.recordercontainer =$('#ttrec_container_' + this.uniqueid);\n            this.controls.recorderbutton = $('#' + this.uniqueid + '_recorderdiv');\n            this.controls.timerstatus = $('.timerstatus_' + this.uniqueid);\n            this.passagehash = this.controls.recorderbutton.data('passagehash');\n            this.region=this.controls.recorderbutton.data('region');\n            this.lang=this.controls.recorderbutton.data('lang');\n            this.asrurl=this.controls.recorderbutton.data('asrurl');\n            this.streamingtoken=this.controls.recorderbutton.data('streamingtoken');\n            this.maxtime=this.controls.recorderbutton.data('maxtime');\n            this.waveHeight=this.controls.recorderbutton.data('waveheight');\n        },\n\n        silence_detected: function(){\n            if(this.audio.isRecording){\n                this.toggleRecording();\n            }\n        },\n\n        update_audio: function(newprops,val){\n            if (typeof newprops === 'string') {\n                log.debug('update_audio:' + newprops + ':' + val);\n                if (this.audio[newprops] !== val) {\n                    this.audio[newprops] = val;\n                    this.audio_updated();\n                }\n            }else{\n                for (var theprop in newprops) {\n                    this.audio[theprop] = newprops[theprop];\n                    log.debug('update_audio:' + theprop + ':' + newprops[theprop]);\n                }\n                this.audio_updated();\n            }\n        },\n\n        register_events: function(){\n            var that = this;\n            this.controls.recordercontainer.click(function(){\n                that.toggleRecording();\n            });\n\n            this.audio_updated=function() {\n                //pointer\n                if (that.audio.isRecognizing || that.audio.isWaiting ) {\n                    that.show_recorder_pointer('none');\n                } else {\n                    that.show_recorder_pointer('auto');\n                }\n                //the color\n                if(that.audio.isRecognizing || that.audio.isRecording ) {\n                    this.controls.recorderbutton.removeClass('ttrec_ready');\n                    this.controls.recorderbutton.addClass('ttrec_engaged');\n                }else{\n                    this.controls.recorderbutton.removeClass('ttrec_engaged');\n                    this.controls.recorderbutton.addClass('ttrec_ready');\n                }\n\n                //the font awesome spinner/mic/square\n                that.controls.recorderbutton.html(that.recordBtnContent());\n            };\n\n        },\n\n        show_recorder_pointer: function(show){\n            if(show) {\n                this.controls.recorderbutton.css('pointer-events', 'none');\n            }else{\n                this.controls.recorderbutton.css('pointer-events', 'auto');\n            }\n\n        },\n\n        gotRecognition:function(transcript){\n            log.debug('transcript:' + transcript);\n            if(transcript.trim()==''){return;}\n            var message={};\n            message.type='speech';\n            message.capturedspeech = transcript;\n            this.callback(message);\n        },\n\n        gotInterimRecognition:function(transcript){\n            var message={};\n            message.type='interimspeech';\n            message.capturedspeech = transcript;\n           //POINT\n            this.callback(message);\n        },\n\n        cleanWord: function(word) {\n            return word.replace(/['!\"#$%&\\\\'()\\*+,\\-\\.\\/:;<=>?@\\[\\\\\\]\\^_`{|}~']/g,\"\").toLowerCase();\n        },\n\n        recordBtnContent: function() {\n\n            if(!this.audio.isRecognizing){\n\n                if (this.audio.isRecording) {\n                    return '<i class=\"fa fa-stop\">';\n\n                } else if(this.audio.isWaiting) {\n                    return '<i class=\"fa fa-spinner fa-spin\">';\n\n                } else {\n                    return '<i class=\"fa fa-microphone\">';\n                }\n            } else {\n                return '<i class=\"fa fa-spinner fa-spin\">';\n            }\n        },\n        toggleRecording: function() {\n            var that =this;\n\n            //If we are recognizing, then we want to discourage super click'ers\n            if (this.audio.isRecognizing) {\n                return;\n            }\n\n            //If we are current recording\n            if (this.audio.isRecording) {\n                that.timer.stop();\n\n                //If using Browser Rec (chrome speech)\n                if(this.usebrowserrec){\n                    that.update_audio('isRecording',false);\n                    that.update_audio('isRecognizing',true);\n                    this.browserrec.stop();\n                //If using DS rec\n                }else{\n                    this.update_audio('isRecognizing',true);\n                    this.audiohelper.stop();\n                }\n\n             //If we are NOT currently recording\n            } else {\n                // Run the timer\n                that.currentTime = 0;\n                that.timer.reset();\n                that.timer.start();\n                \n\n                //If using Browser Rec (chrome speech)\n                if(this.usebrowserrec){\n                    this.update_audio('isRecording',true);\n                    this.browserrec.start();\n\n                //If using Audio helper\n                }else {\n                    var newaudio = {\n                        stream: null,\n                        blob: null,\n                        dataURI: null,\n                        start: new Date(),\n                        end: null,\n                        isRecording: false,\n                        isRecognizing: false,\n                        isWaiting: false,\n                        transcript: null\n                    };\n                    this.update_audio(newaudio);\n                    this.audiohelper.start();\n                }\n            }\n        },\n\n        deepSpeech2: function(blob, callback) {\n            var bodyFormData = new FormData();\n            var blobname = this.uniqueid + Math.floor(Math.random() * 100) +  '.wav';\n            bodyFormData.append('audioFile', blob, blobname);\n            bodyFormData.append('scorer', this.passagehash);\n            if(this.stt_guided) {\n                bodyFormData.append('strictmode', 'false');\n            }else{\n                bodyFormData.append('strictmode', 'true');\n            }\n            //prompt is used by whisper and other transcibers down the line\n            if(this.currentPrompt!==false){\n                bodyFormData.append('prompt', this.currentPrompt);\n            }\n            bodyFormData.append('lang', this.lang);\n            bodyFormData.append('wwwroot', M.cfg.wwwroot);\n\n            var oReq = new XMLHttpRequest();\n            oReq.open(\"POST\", this.asrurl, true);\n            oReq.onUploadProgress= function(progressEvent) {};\n            oReq.onload = function(oEvent) {\n                if (oReq.status === 200) {\n                    callback(JSON.parse(oReq.response));\n                } else {\n                    callback({data: {result: \"error\"}});\n                    log.debug(oReq.error);\n                }\n            };\n            try {\n                oReq.send(bodyFormData);\n            }catch(err){\n                callback({data: {result: \"error\"}});\n                log.debug(err);\n            }\n        },\n\n    };//end of return value\n\n});"],"names":["define","$","log","notification","audioHelper","browserRec","str","timer","debug","waveHeight","audio","stream","blob","dataURI","start","end","isRecording","isRecognizing","isWaiting","transcript","submitting","owner","controls","uniqueid","audio_updated","maxtime","passagehash","region","asrurl","lang","browserrec","usebrowserrec","currentTime","stt_guided","currentPrompt","streamingtoken","strings","clone","extend","this","init","opts","that","callback","init_strings","prepare_html","recordercontainer","show","register_events","handle_timer_update","displaytime","fetch_display_time","timerstatus","html","seconds","initseconds","update_audio","stop","audiohelper","on_error","error","name","alert","allowmicaccess","nomicdetected","on_stopped","undefined","newaudio","URL","createObjectURL","Date","length","Math","round","is_streaming","deepSpeech2","response","data","result","gotRecognition","trim","speechnotrecognized","on_gotstream","will_work_ok","onError","onStop","onSocketReady","onfinalspeechcapture","speechtext","oninterimspeechcapture","gotInterimRecognition","onStream","onerror","onend","onstart","get_strings","done","s","i","recorderbutton","silence_detected","toggleRecording","newprops","val","theprop","click","show_recorder_pointer","removeClass","addClass","recordBtnContent","css","message","capturedspeech","cleanWord","word","replace","toLowerCase","reset","bodyFormData","FormData","blobname","floor","random","append","M","cfg","wwwroot","oReq","XMLHttpRequest","open","onUploadProgress","progressEvent","onload","oEvent","status","JSON","parse","send","err"],"mappings":"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"}