{"version":3,"file":"ttrecorder.min.js","sources":["../src/ttrecorder.js"],"sourcesContent":["define(['jquery', 'core/log','core/notification', 'core/ajax', 'mod_minilesson/ttaudiohelper','mod_minilesson/ttbrowserrec',\n    'core/str','mod_minilesson/timer','mod_minilesson/ttmsspeech', 'mod_minilesson/mediauploader'],\n    function ($, log, notification, ajax, audioHelper, browserRec, str, timer, msspeech, mediauploader) {\n    \"use strict\"; // jshint ;_;\n    /*\n    *  The TT recorder\n     */\n\n    log.debug('TT Recorder: initialising');\n\n    return {\n        waveHeight: 75,\n        audio: {\n            stream: null,\n            blob: null,\n            dataURI: null,\n            start: null,\n            end: null,\n            isRecording: false,\n            isRecognizing: false,\n            isWaiting: false,\n            transcript: null\n        },\n        submitting: false,\n        owner: '',\n        controls: {},\n        uniqueid: null,\n        audio_updated: null,\n        maxtime: 0,\n        passagehash: null,\n        region: null,\n        asrurl: null,\n        lang: null,\n        browserrec: null,\n        usebrowserrec: false,\n        currentTime: 0,\n        stt_guided: false,\n        currentPrompt: false,\n        speechtoken: '',\n        speechtokenvalidseconds: '',\n        speechtokentype: '',\n        forcestreaming: false,\n        is_streaming: false,\n        using_msspeech: false,\n        msspeech_instance: null,\n        savemedia: false,\n        uploader: null,\n        strings: {},\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        init: function(opts){\n\n            var that = this;\n            this.uniqueid=opts['uniqueid'];\n            this.callback=opts['callback'];\n            this.stt_guided = opts['stt_guided'] ? opts['stt_guided'] : false;\n            this.init_strings();\n            this.prepare_html();\n            this.controls.recordercontainer.show();\n            this.register_events();\n\n            //init media uploader\n            log.debug('ttr uploader savemedia: ' + this.savemedia);\n            if(this.savemedia) {\n                log.debug('ttr uploader creating: ');\n                that.uploader = mediauploader.clone();\n                var uconfig = {};\n                uconfig.wstoken = that.wstoken;\n                uconfig.moodlewsrestformat = \"\";\n                uconfig.mediatype = that.mediatype;\n                uconfig.parent = that.wwwroot;\n                uconfig.appid = that.appid;\n                uconfig.owner = that.owner;\n                uconfig.region = that.savemediaregion;\n                uconfig.expiredays = that.expiredays;\n                uconfig.transcode = that.transcode ? 1 : 0;\n                uconfig.cloudpoodllurl = that.cloudpoodllurl;\n                uconfig.transcoder = \"default\";\n                uconfig.transcribe = 0;\n                uconfig.subtitle = 0;\n                uconfig.language = that.lang;\n                uconfig.transcribevocab = \"none\";\n                uconfig.notificationurl = \"none\";\n                that.uploader.init(uconfig);\n            }\n\n            //token check\n            this.using_msspeech = this.can_msspeech();\n            if(this.using_msspeech){\n                var referencetext = opts['referencetext'];\n                this.msspeech_instance = msspeech.clone();\n                this.msspeech_instance.init(this.speechtoken, this.region, this.lang, referencetext);\n            }\n\n            // Callback: Timer updates.\n            var handle_timer_update = function(){\n                var displaytime = that.timer.fetch_display_time();\n                that.controls.timerstatus.html(displaytime);\n                log.debug('timer_seconds: ' + that.timer.seconds);\n                log.debug('displaytime: ' + displaytime);\n                if (that.timer.seconds == 0 && that.timer.initseconds > 0) {\n                    that.update_audio('isRecognizing', true);\n                    if(that.usebrowserrec){\n                        that.browserrec.stop();\n                    }else{\n                        that.audiohelper.stop();\n                    }\n                }\n            };\n\n            // Callback: Recorder device errors.\n            var on_error = function(error) {\n                switch (error.name) {\n                    case 'PermissionDeniedError':\n                    case 'NotAllowedError':\n                        notification.alert(\"Error\",that.strings.allowmicaccess, \"OK\");\n                        break;\n                    case 'DevicesNotFoundError':\n                    case 'NotFoundError':\n                        notification.alert(\"Error\",that.strings.nomicdetected, \"OK\");\n                        break;\n                    default:\n                        //other errors, like from Edge can fire repeatedly so a notification is not a good idea\n                        //notification.alert(\"Error\", error.name, \"OK\");\n                        log.debug(\"Error\", error.name);\n                }\n            };\n\n            // Callback: Recording stopped.\n            var on_stopped = function(blob) {\n                that.timer.stop()\n\n                //if the blob is undefined then the user is super clicking or something\n                if(blob===undefined){\n                    return;\n                }\n\n                //Update our current audio object\n                var newaudio = {\n                    blob: blob,\n                    dataURI: URL.createObjectURL(blob),\n                    end: new Date(),\n                    isRecording: false,\n                    length: Math.round((that.audio.end - that.audio.start) / 1000),\n                };\n                that.update_audio(newaudio);\n\n                //if we are not streaming then upload_transcribe (ie send to poodll servers)\n                if(!that.is_streaming){\n                    if(that.using_msspeech){\n                        that.do_msspeech(that.audio.blob, function(response){\n                            that.gotMSResults(response);\n                            that.update_audio('isRecognizing',false);\n                        });\n                    }else{\n                        that.upload_transcribe(that.audio.blob, function(response){\n                            log.debug(response);\n                            if(response.data.result===\"success\" && response.data.transcript){\n                                that.gotRecognition(response.data.transcript.trim());\n                            } else {\n                                notification.alert(\"Information\",that.strings.speechnotrecognized, \"OK\");\n                            }\n                            that.update_audio('isRecognizing',false);\n                        });\n                    }\n\n                    // If we have a blob and we need to upload it, do so\n                    if (that.savemedia) {\n                        that.uploader.uploadBlob(that.audio.blob, 'audio/wav');\n                        var message = {};\n                        message.type = 'mediasaved';\n                        message.mediaurl = that.uploader.config.s3root + that.uploader.config.s3filename;\n                        log.debug('ttr uploader: callback mediasaved');\n                        log.debug(message);\n                        that.callback(message);\n                    }\n                }\n\n            };\n\n            // Callback: Recorder device got stream - start recording\n            var on_gotstream=  function(stream) {\n                var newaudio={stream: stream, isRecording: true, isWaiting: false};\n                that.update_audio(newaudio);\n            };\n\n            //If browser rec (Chrome Speech Rec) \n            if(browserRec.will_work_ok() && ! this.stt_guided && !this.forcestreaming && !this.using_msspeech){\n                //Init browserrec\n                log.debug(\"using browser rec\");\n                this.browserrec = browserRec.clone();\n                this.browserrec.init(this.lang,this.waveHeight,this.uniqueid);\n                this.usebrowserrec=true;\n\n                //set up events\n                that.browserrec.onerror = on_error;\n                that.browserrec.onend = function(){\n                        //do something here\n                };\n                that.browserrec.onstart = function(){\n                    //do something here\n                };\n                that.browserrec.onfinalspeechcapture=function(speechtext){\n                    that.gotRecognition(speechtext);\n                    that.update_audio('isRecording',false);\n                    that.update_audio('isRecognizing',false);\n                };\n\n                that.browserrec.oninterimspeechcapture=function(speechtext){\n                    that.gotInterimRecognition(speechtext);\n                };\n\n\n            //If we have a streaming token\n            }else if( this.can_stream() && !this.stt_guided ) {\n                this.is_streaming = true;\n                //Init streaming audio helper\n                log.debug(\"using audio helper and streaming rec\");\n                this.audiohelper =  audioHelper.clone();\n                this.audiohelper.init(this.waveHeight,this.uniqueid, this);\n\n                that.audiohelper.onError = on_error;\n                that.audiohelper.onStop = on_stopped;\n                that.audiohelper.onStream = on_gotstream;\n                that.audiohelper.onfinalspeechcapture = function(speechtext){\n                    that.gotRecognition(speechtext);\n                    that.update_audio('isRecording',false);\n                    that.update_audio('isRecognizing',false);\n                };\n                that.audiohelper.oninterimspeechcapture = function(speechtext){\n                    that.gotInterimRecognition(speechtext);\n                };\n                \n            //If upload_transcriber\n            } else {\n                //set up upload_transcriber\n                log.debug(\"using upload_transcriber\");\n                this.audiohelper =  audioHelper.clone();\n                this.audiohelper.init(this.waveHeight,this.uniqueid,this);\n\n                that.audiohelper.onError = on_error;\n                that.audiohelper.onStop = on_stopped;\n                that.audiohelper.onStream = on_gotstream;\n\n            }//end of setting up recorders\n\n            // Set up token refresh\n            log.debug('original speechtoken - ' + this.speechtoken);\n            log.debug('speechtokentype - ' + this.speechtokentype);\n            log.debug('speechtokenvalidseconds - ' + this.speechtokenvalidseconds);\n            this.init_token_refresh();\n\n            // Setting up timer.\n            this.timer = timer.clone();\n            this.timer.init(this.maxtime, handle_timer_update);\n            // Init the timer readout\n            handle_timer_update();\n        },\n\n        can_stream: function( ){\n            return (this.speechtoken && this.speechtoken !== 'false'&& this.speechtokentype === 'assemblyai' && !this.stt_guided);\n        },\n\n        can_msspeech: function( ){\n            return (this.speechtoken && this.speechtoken !== 'false' && this.speechtokentype === 'msspeech');\n        },\n\n        update_currentprompt: function(targettext){\n            this.currentPrompt = targettext;\n            if(this.using_msspeech){\n                this.msspeech_instance.set_reference_text(targettext);\n            }\n        },\n\n        blobToArrayBuffer: function (blob) {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = function(event) {\n                    resolve(event.target.result);\n                };\n                reader.onerror = function(error) {\n                    reject(error);\n                };\n                reader.readAsArrayBuffer(blob);\n            });\n        },\n\n        init_strings: function(){\n            var that=this;\n            str.get_strings([\n                { \"key\": \"allowmicaccess\", \"component\": 'mod_minilesson'},\n                { \"key\": \"nomicdetected\", \"component\": 'mod_minilesson'},\n                { \"key\": \"speechnotrecognized\", \"component\": 'mod_minilesson'},\n\n            ]).done(function (s) {\n                var i = 0;\n                that.strings.allowmicaccess = s[i++];\n                that.strings.nomicdetected = s[i++];\n                that.strings.speechnotrecognized = s[i++];\n            });\n        },\n\n        prepare_html: function(){\n            this.controls.recordercontainer =$('#ttrec_container_' + this.uniqueid);\n            this.controls.recorderbutton = $('#' + this.uniqueid + '_recorderdiv');\n            this.controls.waveform = $('#' + this.uniqueid + '_waveform');\n            this.controls.timerstatus = $('.timerstatus_' + this.uniqueid);\n            this.passagehash = this.controls.recorderbutton.data('passagehash');\n            this.region=this.controls.recorderbutton.data('region');\n            this.lang=this.controls.recorderbutton.data('lang');\n            this.asrurl=this.controls.recorderbutton.data('asrurl');\n            this.speechtoken=this.controls.recorderbutton.data('speechtoken');\n            this.speechtokenvalidseconds=this.controls.recorderbutton.data('speechtokenvalidseconds');\n            this.speechtokentype=this.controls.recorderbutton.data('speechtokentype');\n            this.forcestreaming=this.controls.recorderbutton.data('forcestreaming');\n            this.maxtime=this.controls.recorderbutton.data('maxtime');\n            this.waveHeight=this.controls.recorderbutton.data('waveheight');\n            // Whether to save media and related\n            this.savemedia = this.controls.recorderbutton.data('savemedia') === 1;\n            this.savemediaregion = this.controls.recorderbutton.data('savemediaregion');\n            this.wstoken = this.controls.recorderbutton.data('wstoken');\n            this.wwwroot = this.controls.recorderbutton.data('wwwroot');\n            this.appid = this.controls.recorderbutton.data('appid');\n            this.owner = this.controls.recorderbutton.data('owner');\n            this.transcode = this.controls.recorderbutton.data('transcode') === 1;\n            this.expiredays = this.controls.recorderbutton.data('expiredays');\n            this.mediatype = this.controls.recorderbutton.data('mediatype');\n            this.cloudpoodllurl = this.controls.recorderbutton.data('cloudpoodllurl');\n\n        },\n\n        init_token_refresh: function() {\n            var that = this;\n            var validsecs = Number(that.speechtokenvalidseconds) || 0;\n            // If we have a token, then we can set up a timer to refresh it\n            if (that.speechtoken && validsecs > 0) {\n                //(valid until seconds - now seconds) => milliseconds\n                var refreshInterval = validsecs * 1000;\n                log.debug('Refreshing ' + that.speechtokentype +' token after ' + refreshInterval + ' milliseconds');\n                if (refreshInterval > 0) {\n                    setTimeout(function() {\n                        // Refresh the token\n                        log.debug('Refreshing streaming token...');\n                        var ajaxresult =  ajax.call([{\n                            methodname: 'mod_minilesson_refresh_token',\n                            args: {\n                                'type': that.speechtokentype,\n                                'region': that.region\n                            },\n                            async: false\n                        }])[0].then(ajaxresult => {\n                            log.debug('New token ajaxresult:', ajaxresult);\n                            var newtoken = JSON.parse(ajaxresult);\n                            log.debug('New token received:', newtoken);\n                            // Update our internal token\n                            if(newtoken && newtoken.token) {\n                                that.speechtoken = newtoken.token;\n                                that.speechtokenvalidseconds = newtoken.validseconds;\n                                switch (that.speechtokentype) {\n                                    case 'assemblyai':\n                                        that.helper.streamer.updatetoken(newtoken.token);\n                                        break;\n                                    case 'msspeech':\n                                        that.msspeech_instance.updatetoken(newtoken.token);\n                                        break;\n                                }\n                                log.debug('Streaming token refreshed successfully.');\n                                // Start the countdown all over again\n                                that.init_token_refresh();\n                            } else {\n                                log.debug('New token was not a token.');\n                            }\n                        });\n                        \n                    }, refreshInterval);\n                    \n                } else {\n                    log.debug('Refresh interval is 0. Not refreshing token.');\n                }\n            } else {\n                log.debug('No valid streaming token available, skipping refresh setup.');\n            }\n        },\n\n        silence_detected: function(){\n            if(this.audio.isRecording){\n                this.toggleRecording();\n            }\n        },\n\n        update_audio: function(newprops,val){\n            if (typeof newprops === 'string') {\n                log.debug('update_audio:' + newprops + ':' + val);\n                if (this.audio[newprops] !== val) {\n                    this.audio[newprops] = val;\n                    this.audio_updated();\n                }\n            }else{\n                for (var theprop in newprops) {\n                    this.audio[theprop] = newprops[theprop];\n                    log.debug('update_audio:' + theprop + ':' + newprops[theprop]);\n                }\n                this.audio_updated();\n            }\n        },\n\n        register_events: function(){\n            var that = this;\n            this.controls.recordercontainer.click(function(){\n                that.toggleRecording();\n            });\n\n            this.audio_updated=function() {\n                //pointer\n                if (that.audio.isRecognizing || that.audio.isWaiting ) {\n                    that.show_recorder_pointer('none');\n                } else {\n                    that.show_recorder_pointer('auto');\n                }\n                //the color\n                //we no longer swap out colors for waiting .. its too fast and a bit jarring\n                if(that.audio.isRecognizing || that.audio.isWaiting){\n                    this.controls.recorderbutton.removeClass('ttrec_ready');\n                    this.controls.recorderbutton.removeClass('ttrec_waiting');\n                    this.controls.waveform.removeClass('ttrec_waiting');\n                    this.controls.recorderbutton.removeClass('ttrec_isrecording');\n                    this.controls.recorderbutton.addClass('ttrec_engaged');\n                } else if (that.audio.isRecording) {\n                    this.controls.recorderbutton.removeClass('ttrec_ready');\n                    this.controls.waveform.removeClass('ttrec_waiting');\n                    this.controls.recorderbutton.removeClass('ttrec_waiting');\n                    this.controls.recorderbutton.removeClass('ttrec_engaged');\n                    this.controls.recorderbutton.addClass('ttrec_isrecording');\n                }else if (that.audio.isWaiting && false) {\n                    this.controls.recorderbutton.removeClass('ttrec_engaged');\n                    this.controls.recorderbutton.removeClass('ttrec_ready');\n                    this.controls.recorderbutton.removeClass('ttrec_isrecording');\n                    this.controls.recorderbutton.addClass('ttrec_waiting');\n                    this.controls.waveform.addClass('ttrec_waiting');\n                }else{\n                    this.controls.recorderbutton.removeClass('ttrec_engaged');\n                    this.controls.recorderbutton.removeClass('ttrec_waiting');\n                    this.controls.recorderbutton.removeClass('ttrec_isrecording');\n                    this.controls.waveform.removeClass('ttrec_waiting');\n                    this.controls.recorderbutton.addClass('ttrec_ready');\n                }\n\n                //the font awesome spinner/mic/square\n                that.controls.recorderbutton.html(that.recordBtnContent());\n            };\n\n        },\n\n        show_recorder_pointer: function(show){\n            if(show) {\n                this.controls.recorderbutton.css('pointer-events', 'none');\n            }else{\n                this.controls.recorderbutton.css('pointer-events', 'auto');\n            }\n\n        },\n\n        startedRecording:function(){\n\n            var message={};\n            message.type='recording';\n            message.results = '';\n            this.callback(message);\n        },\n\n        gotMSResults:function(results){\n            log.debug(results);\n            var message={};\n            message.type='pronunciation_results';\n            message.results = results;\n            this.callback(message);\n        },\n\n        gotRecognition:function(transcript){\n            log.debug('transcript:' + transcript);\n            if(transcript.trim()==''){return;}\n            var message={};\n            message.type='speech';\n            message.capturedspeech = transcript;\n            this.callback(message);\n        },\n\n        gotInterimRecognition:function(transcript){\n            var message={};\n            message.type='interimspeech';\n            message.capturedspeech = transcript;\n           //POINT\n            this.callback(message);\n        },\n\n        cleanWord: function(word) {\n            return word.replace(/['!\"#$%&\\\\'()\\*+,\\-\\.\\/:;<=>?@\\[\\\\\\]\\^_`{|}~']/g,\"\").toLowerCase();\n        },\n\n        recordBtnContent: function() {\n\n            if(!this.audio.isRecognizing){\n\n                if (this.audio.isRecording) {\n                    return '<i class=\"fa fa-stop\">';\n\n                } else if(this.audio.isWaiting) {\n                    return '<i class=\"fa fa-solid fa-cog fa-spin\">';\n\n                } else {\n                    return '<i class=\"fa fa-microphone\">';\n                }\n            } else {\n                return '<i class=\"fa fa-spinner fa-spin\">';\n            }\n        },\n        toggleRecording: function() {\n            var that =this;\n\n            //If we are recognizing, then we want to discourage super click'ers\n            if (this.audio.isRecognizing || this.audio.isWaiting) {\n                return;\n            }\n\n            //If we are currently recording\n            if (this.audio.isRecording) {\n                that.timer.stop();\n\n                //If using Browser Rec (chrome speech)\n                if(this.usebrowserrec){\n                    that.update_audio('isRecording',false);\n                    that.update_audio('isRecognizing',true);\n                    this.browserrec.stop();\n\n                //If using upload_transcriber or streaming\n                }else{\n                    this.update_audio('isRecognizing',true);\n                    this.audiohelper.stop();\n                }\n\n             //If we are NOT currently recording\n            } else {\n                // Run the timer\n                that.currentTime = 0;\n                that.timer.reset();\n                that.timer.start();\n                \n\n                //If using Browser Rec (chrome speech)\n                if(this.usebrowserrec){\n                    this.update_audio('isRecording',true);\n                    this.browserrec.start();\n\n                //If using Audio helper for upload_transcriber or streaming\n                }else {\n                    var newaudio = {\n                        stream: null,\n                        blob: null,\n                        dataURI: null,\n                        start: new Date(),\n                        end: null,\n                        isRecording: false,\n                        isRecognizing: false,\n                        isWaiting: true,\n                        transcript: null\n                    };\n                    this.update_audio(newaudio);\n                    this.audiohelper.start();\n                }\n                this.startedRecording();\n            }\n        },\n\n        upload_transcribe: function(blob, callback) {\n            var bodyFormData = new FormData();\n            var blobname = this.uniqueid + Math.floor(Math.random() * 100) +  '.wav';\n            bodyFormData.append('audioFile', blob, blobname);\n            bodyFormData.append('scorer', this.passagehash);\n            if(this.stt_guided) {\n                bodyFormData.append('strictmode', 'false');\n            }else{\n                bodyFormData.append('strictmode', 'true');\n            }\n            //prompt is used by whisper and other transcibers down the line\n            if(this.currentPrompt!==false){\n                bodyFormData.append('prompt', this.currentPrompt);\n            }\n            bodyFormData.append('lang', this.lang);\n            bodyFormData.append('wwwroot', M.cfg.wwwroot);\n\n            var oReq = new XMLHttpRequest();\n            oReq.open(\"POST\", this.asrurl, true);\n            oReq.onUploadProgress= function(progressEvent) {};\n            oReq.onload = function(oEvent) {\n                if (oReq.status === 200) {\n                    callback(JSON.parse(oReq.response));\n                } else {\n                    callback({data: {result: \"error\"}});\n                    log.debug(oReq.error);\n                }\n            };\n            try {\n                oReq.send(bodyFormData);\n            }catch(err){\n                callback({data: {result: \"error\"}});\n                log.debug(err);\n            }\n        },\n\n        do_msspeech: function(blob, callback) {\n            this.msspeech_instance.recognize(blob,callback)\n        },\n\n    };//end of return value\n\n});"],"names":["define","$","log","notification","ajax","audioHelper","browserRec","str","timer","msspeech","mediauploader","debug","waveHeight","audio","stream","blob","dataURI","start","end","isRecording","isRecognizing","isWaiting","transcript","submitting","owner","controls","uniqueid","audio_updated","maxtime","passagehash","region","asrurl","lang","browserrec","usebrowserrec","currentTime","stt_guided","currentPrompt","speechtoken","speechtokenvalidseconds","speechtokentype","forcestreaming","is_streaming","using_msspeech","msspeech_instance","savemedia","uploader","strings","clone","extend","this","init","opts","that","callback","init_strings","prepare_html","recordercontainer","show","register_events","uconfig","wstoken","moodlewsrestformat","mediatype","parent","wwwroot","appid","savemediaregion","expiredays","transcode","cloudpoodllurl","transcoder","transcribe","subtitle","language","transcribevocab","notificationurl","can_msspeech","referencetext","handle_timer_update","displaytime","fetch_display_time","timerstatus","html","seconds","initseconds","update_audio","stop","audiohelper","on_error","error","name","alert","allowmicaccess","nomicdetected","on_stopped","undefined","newaudio","URL","createObjectURL","Date","length","Math","round","do_msspeech","response","gotMSResults","upload_transcribe","data","result","gotRecognition","trim","speechnotrecognized","uploadBlob","message","mediaurl","config","s3root","s3filename","on_gotstream","will_work_ok","can_stream","onError","onStop","onStream","onfinalspeechcapture","speechtext","oninterimspeechcapture","gotInterimRecognition","onerror","onend","onstart","init_token_refresh","update_currentprompt","targettext","set_reference_text","blobToArrayBuffer","Promise","resolve","reject","reader","FileReader","onload","event","target","readAsArrayBuffer","get_strings","done","s","i","recorderbutton","waveform","validsecs","Number","refreshInterval","setTimeout","call","methodname","args","async","then","ajaxresult","newtoken","JSON","parse","token","validseconds","helper","streamer","updatetoken","silence_detected","toggleRecording","newprops","val","theprop","click","show_recorder_pointer","removeClass","addClass","recordBtnContent","css","startedRecording","results","capturedspeech","cleanWord","word","replace","toLowerCase","reset","bodyFormData","FormData","blobname","floor","random","append","M","cfg","oReq","XMLHttpRequest","open","onUploadProgress","progressEvent","oEvent","status","send","err","recognize"],"mappings":"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"}