{"version":3,"file":"ttstreamer.min.js","sources":["../src/ttstreamer.js"],"sourcesContent":["define(['jquery', 'core/log'], function ($, log) {\n    \"use strict\"; // jshint ;_;\n    /*\n    This file is the engine that drives audio rec and canvas drawing. TT Recorder is the just the glory kid\n     */\n\n    log.debug('TT Streamer initialising');\n\n    return {\n\n        streamingtoken: null,\n        socket: null,\n        audiohelper: null,\n        earlyaudio: [],\n        partials: [],\n        finals: [],\n        ready: false,\n        finaltext: '',\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        init: function(streamingtoken, theaudiohelper) {\n            this.streamingtoken = streamingtoken;\n            this.audiohelper = theaudiohelper;\n            this.preparesocket();\n\n        },\n\n        preparesocket: async function(){\n            var that = this;\n\n            // establish wss with AssemblyAI (AAI) at 16000 sample rate\n            switch(this.audiohelper.region){\n                case 'frankfurt':\n                case 'london':\n                case 'dublin':\n                    //did not work\n               //     this.socket = await new WebSocket(\n               //         `wss://api.eu.assemblyai.com/v2/realtime/ws?sample_rate=16000&encoding=pcm_s16le&token=${this.streamingtoken}`,\n                //    );\n                //    break;\n                default:\n                    this.socket = await new WebSocket(\n                        `wss://api.assemblyai.com/v2/realtime/ws?sample_rate=16000&encoding=pcm_s16le&token=${this.streamingtoken}`,\n                    );\n            }\n            log.debug('TT Streamer socket prepared');\n            \n\n            // handle incoming messages which contain the transcription\n            this.socket.onmessage= function(message) {\n                let msg = \"\";\n                const res = JSON.parse(message.data);\n                switch(res.message_type){\n                    case 'PartialTranscript':\n                        that.partials[res.audio_start] = res.text;\n                        var keys = Object.keys(that.partials);\n                        keys.sort((a, b) => a - b);\n                        for (const key of keys) {\n                            if (that.partials[key]) {\n                                msg += ` ${that.partials[key]}`;\n                            }\n                        }\n                        that.audiohelper.oninterimspeechcapture(that.finaltext + ' ' + msg);\n                        break;\n\n                    case 'FinalTranscript':\n                        //clear partials if we have a final\n                        that.partials = [];\n                        //process finals\n                        that.finals[res.audio_start] = res.text;\n                        var keys = Object.keys(that.finals);\n                        keys.sort((a, b) => a - b);\n                        for (const key of keys) {\n                            if (that.finals[key]) {\n                                msg += ` ${that.finals[key]}`;\n                            }\n                        }\n                        that.finaltext = msg;\n                        //we do not send final speech capture event until the speaking session ends\n                        //that.audiohelper.onfinalspeechcapture(msg);\n                        that.audiohelper.oninterimspeechcapture(msg);\n                        log.debug('interim (final) transcript: ' + msg);\n                        break;\n                    case 'SessionBegins':\n                            log.debug('TT Streamer session begins');\n                            that.ready = true;\n                            break;      \n                    case 'SessionEnds':\n                            break;    \n                    case 'SessionInformation':\n                        break;\n                    case 'RealtimeError':\n                        log.debug(res.error);\n                        break;    \n                    default:\n                        break;\n                }\n                log.debug(msg);\n            };\n\n            this.socket.onopen = (event) => {\n                log.debug('TT Streamer socket opened');\n                that.partials = [];\n                that.finals = [];\n                that.audiohelper.onSocketReady('fromsocketopen');\n            };\n\n            this.socket.onerror = (event) => {\n                log.debug(event);\n                that.socket.close();\n            };\n\n            this.socket.onclose = (event) => {\n                log.debug(event);\n                that.socket = null;\n            };\n        },\n\n        audioprocess: function(stereodata) {\n            var that = this;\n            const base64data = this.binarytobase64(stereodata[0]);\n\n            //this would be an event that occurs after recorder has stopped or before we are ready\n            //session opening can be slower than socket opening, so store audio data until session is open\n            if(this.ready===undefined || !this.ready){\n                log.debug('TT Streamer storing base64 audio');\n                this.earlyaudio.push(base64data);\n\n            //session opened after we collected audio data, send earlyaudio first\n            }else if(this.earlyaudio.length > 0 ){\n                for (var i=0; i < this.earlyaudio.length; i++) {\n                    this.sendaudio(this.earlyaudio[i]);\n                }\n                //clear earlyaudio and send the audio we just got\n                this.earlyaudio = [];\n                this.sendaudio(base64data);\n\n            }else{\n                //just send the audio we got\n                log.debug('TT Streamer sending current audiodata');\n                this.sendaudio(base64data);\n            }\n        },\n\n        binarytobase64: function(monoaudiodata) {\n            var that = this;\n\n            //convert to 16 bit pcm\n            var tempbuffer = []\n            for (let i = 0; i < monoaudiodata.length; i++) {\n                const sample = Math.max(-1, Math.min(1, monoaudiodata[i]))\n                const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7fff\n                tempbuffer.push(intSample & 0xff)\n                tempbuffer.push((intSample >> 8) & 0xff)\n            }\n            var sendbuffer = new Uint8Array(tempbuffer)\n\n            // Encode binary string to base64\n            var binary = '';\n            for (var i = 0; i < sendbuffer.length; i++) {\n                binary += String.fromCharCode(sendbuffer[i]);\n            }\n            var base64 = btoa(binary);\n            return base64;\n        },\n\n        sendaudio: function(base64) {\n            var that = this;\n            //Send it off !!\n            if (that.socket) {\n                that.socket.send(\n                    JSON.stringify({\n                        audio_data: base64,\n                    }),\n                );\n            }\n        },\n\n        finish: function(mimeType) {\n            var that = this;\n\n            //this would be an event that occurs after recorder has stopped lets just ignore it\n            if(this.ready===undefined || !this.ready){\n                return;\n            }\n            log.debug('forcing end utterance');\n            //get any remanining transcription\n            if (that.socket) {\n                that.socket.send(\n                    JSON.stringify({\n                        force_end_utterance: true,\n                    }),\n                );\n            }\n            log.debug('timing out');\n            setTimeout(function() {\n                var msg = \"\";\n                var sets = [that.finals,that.partials];\n                for (const set of sets) {\n                    var keys = Object.keys(set);\n                    keys.sort((a, b) => a - b);\n                    for (const key of keys) {\n                        if (set[key]) {\n                            msg += ` ${set[key]}`;\n                        }\n                    }\n                }\n                log.debug('sending final speech capture event');\n                that.audiohelper.onfinalspeechcapture(msg);\n                that.cleanup();\n            }, 1000);\n        },\n\n        cancel: function() {\n           this.ready = false;\n           this.earlyaudio = [];\n           this.partials = [];\n           this.finals = [];\n           this.finaltext = '';\n           if(this.socket){\n               this.socket.close();\n           }\n        },\n\n        cleanup: function() {\n            this.cancel();\n        }\n\n     };//end of return value\n\n});"],"names":["define","$","log","debug","streamingtoken","socket","audiohelper","earlyaudio","partials","finals","ready","finaltext","clone","extend","this","init","theaudiohelper","preparesocket","async","that","region","WebSocket","onmessage","message","msg","res","JSON","parse","data","message_type","audio_start","text","keys","Object","sort","a","b","key","oninterimspeechcapture","error","onopen","event","onSocketReady","onerror","close","onclose","audioprocess","stereodata","base64data","binarytobase64","undefined","length","i","sendaudio","push","monoaudiodata","tempbuffer","sample","Math","max","min","intSample","sendbuffer","Uint8Array","binary","String","fromCharCode","btoa","base64","send","stringify","audio_data","finish","mimeType","force_end_utterance","setTimeout","sets","set","onfinalspeechcapture","cleanup","cancel"],"mappings":"AAAAA,mCAAO,CAAC,SAAU,aAAa,SAAUC,EAAGC,YAMxCA,IAAIC,MAAM,4BAEH,CAEHC,eAAgB,KAChBC,OAAQ,KACRC,YAAa,KACbC,WAAY,GACZC,SAAU,GACVC,OAAQ,GACRC,OAAO,EACPC,UAAW,GAGXC,MAAO,kBACIX,EAAEY,QAAO,EAAM,GAAIC,OAG9BC,KAAM,SAASX,eAAgBY,qBACtBZ,eAAiBA,oBACjBE,YAAcU,oBACdC,iBAITA,cAAeC,qBACPC,KAAOL,KAGJA,KAAKR,YAAYc,YAUXf,aAAe,IAAIgB,uGACkEP,KAAKV,iBAGvGF,IAAIC,MAAM,oCAILE,OAAOiB,UAAW,SAASC,aACxBC,IAAM,SACJC,IAAMC,KAAKC,MAAMJ,QAAQK,aACxBH,IAAII,kBACF,oBACDV,KAAKX,SAASiB,IAAIK,aAAeL,IAAIM,MACjCC,KAAOC,OAAOD,KAAKb,KAAKX,WACvB0B,MAAK,CAACC,EAAGC,IAAMD,EAAIC,QACnB,MAAMC,OAAOL,KACVb,KAAKX,SAAS6B,OACdb,gBAAWL,KAAKX,SAAS6B,OAGjClB,KAAKb,YAAYgC,uBAAuBnB,KAAKR,UAAY,IAAMa,eAG9D,sBAKGQ,KAHJb,KAAKX,SAAW,GAEhBW,KAAKV,OAAOgB,IAAIK,aAAeL,IAAIM,MAC/BC,KAAOC,OAAOD,KAAKb,KAAKV,SACvByB,MAAK,CAACC,EAAGC,IAAMD,EAAIC,QACnB,MAAMC,OAAOL,KACVb,KAAKV,OAAO4B,OACZb,gBAAWL,KAAKV,OAAO4B,OAG/BlB,KAAKR,UAAYa,IAGjBL,KAAKb,YAAYgC,uBAAuBd,KACxCtB,IAAIC,MAAM,+BAAiCqB,eAE1C,gBACGtB,IAAIC,MAAM,8BACVgB,KAAKT,OAAQ,YAEhB,kBAEA,uCAEA,gBACDR,IAAIC,MAAMsB,IAAIc,OAKtBrC,IAAIC,MAAMqB,WAGTnB,OAAOmC,OAAUC,QAClBvC,IAAIC,MAAM,6BACVgB,KAAKX,SAAW,GAChBW,KAAKV,OAAS,GACdU,KAAKb,YAAYoC,cAAc,wBAG9BrC,OAAOsC,QAAWF,QACnBvC,IAAIC,MAAMsC,OACVtB,KAAKd,OAAOuC,cAGXvC,OAAOwC,QAAWJ,QACnBvC,IAAIC,MAAMsC,OACVtB,KAAKd,OAAS,OAItByC,aAAc,SAASC,kBAEbC,WAAalC,KAAKmC,eAAeF,WAAW,YAIlCG,IAAbpC,KAAKJ,OAAsBI,KAAKJ,MAK7B,GAAGI,KAAKP,WAAW4C,OAAS,EAAG,KAC5B,IAAIC,EAAE,EAAGA,EAAItC,KAAKP,WAAW4C,OAAQC,SACjCC,UAAUvC,KAAKP,WAAW6C,SAG9B7C,WAAa,QACb8C,UAAUL,iBAIf9C,IAAIC,MAAM,8CACLkD,UAAUL,iBAff9C,IAAIC,MAAM,yCACLI,WAAW+C,KAAKN,aAkB7BC,eAAgB,SAASM,mBAIjBC,WAAa,OACZ,IAAIJ,EAAI,EAAGA,EAAIG,cAAcJ,OAAQC,IAAK,OACrCK,OAASC,KAAKC,KAAK,EAAGD,KAAKE,IAAI,EAAGL,cAAcH,KAChDS,UAAYJ,OAAS,EAAa,MAATA,OAA2B,MAATA,OACjDD,WAAWF,KAAiB,IAAZO,WAChBL,WAAWF,KAAMO,WAAa,EAAK,aAEnCC,WAAa,IAAIC,WAAWP,YAG5BQ,OAAS,GACJZ,EAAI,EAAGA,EAAIU,WAAWX,OAAQC,IACnCY,QAAUC,OAAOC,aAAaJ,WAAWV,WAEhCe,KAAKH,SAItBX,UAAW,SAASe,QACLtD,KAEFT,QAFES,KAGFT,OAAOgE,KACR3C,KAAK4C,UAAU,CACXC,WAAYH,WAM5BI,OAAQ,SAASC,cACTtD,KAAOL,UAGKoC,IAAbpC,KAAKJ,OAAsBI,KAAKJ,QAGnCR,IAAIC,MAAM,yBAENgB,KAAKd,QACLc,KAAKd,OAAOgE,KACR3C,KAAK4C,UAAU,CACXI,qBAAqB,KAIjCxE,IAAIC,MAAM,cACVwE,YAAW,eACHnD,IAAM,GACNoD,KAAO,CAACzD,KAAKV,OAAOU,KAAKX,cACxB,MAAMqE,OAAOD,KAAM,KAChB5C,KAAOC,OAAOD,KAAK6C,KACvB7C,KAAKE,MAAK,CAACC,EAAGC,IAAMD,EAAIC,QACnB,MAAMC,OAAOL,KACV6C,IAAIxC,OACJb,gBAAWqD,IAAIxC,OAI3BnC,IAAIC,MAAM,sCACVgB,KAAKb,YAAYwE,qBAAqBtD,KACtCL,KAAK4D,YACN,OAGPC,OAAQ,gBACAtE,OAAQ,OACRH,WAAa,QACbC,SAAW,QACXC,OAAS,QACTE,UAAY,GACdG,KAAKT,aACCA,OAAOuC,SAInBmC,QAAS,gBACAC"}