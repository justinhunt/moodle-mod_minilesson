{"version":3,"file":"ttstreamer.min.js","sources":["../src/ttstreamer.js"],"sourcesContent":["define(['jquery', 'core/log'], function ($, log) {\n    \"use strict\"; // jshint ;_;\n    /*\n    This file is the engine that drives audio rec and canvas drawing. TT Recorder is the just the glory kid\n     */\n\n    log.debug('TT Streamer initialising');\n\n    return {\n\n        streamingtoken: null,\n        socket: null,\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        init: function(streamingtoken) {\n            this.streamingtoken = streamingtoken;\n            this.preparesocket();\n\n        },\n\n        preparesocket: async function(){\n            var that = this;\n\n            // establish wss with AssemblyAI (AAI) at 16000 sample rate\n            this.socket = await new WebSocket(\n                `wss://api.assemblyai.com/v2/realtime/ws?sample_rate=16000&encoding=pcm_s16le&token=${this.streamingtoken}`,\n            );\n\n            // handle incoming messages which contain the transcription\n            const texts = {};\n            this.socket.onmessage = (message) => {\n                let msg = \"\";\n                const res = JSON.parse(message.data);\n                texts[res.audio_start] = res.text;\n                const keys = Object.keys(texts);\n                keys.sort((a, b) => a - b);\n                for (const key of keys) {\n                    if (texts[key]) {\n                        msg += ` ${texts[key]}`;\n                    }\n                }\n                log.debug(msg);\n            };\n\n            this.socket.onopen = (event) => {\n                log.debug('TT Streamer socket opened');\n                that.ready = true;\n            };\n\n            this.socket.onerror = (event) => {\n                log.debug(event);\n                that.socket.close();\n            };\n\n            this.socket.onclose = (event) => {\n                log.debug(event);\n                that.socket = null;\n            };\n        },\n\n        audioprocess: function(audiodata) {\n            var that = this;\n            //this would be an event that occurs after recorder has stopped lets just ignore it\n            if(this.ready===undefined || !this.ready){\n                return;\n            }\n\n            var monoaudiodata = audiodata[0];\n            var tempbuffer = []\n            for (let i = 0; i < monoaudiodata.length; i++) {\n                const sample = Math.max(-1, Math.min(1, monoaudiodata[i]))\n                const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7fff\n                tempbuffer.push(intSample & 0xff)\n                tempbuffer.push((intSample >> 8) & 0xff)\n            }\n            var sendbuffer = new Uint8Array(tempbuffer)\n\n\n            var binary = '';\n            for (var i = 0; i < sendbuffer.length; i++) {\n                binary += String.fromCharCode(sendbuffer[i]);\n            }\n\n            // Encode binary string to base64\n            var base64 = btoa(binary);\n            if (that.socket) {\n                that.socket.send(\n                    JSON.stringify({\n                        audio_data: base64,\n                    }),\n                );\n            }\n        },\n\n\n        finish: function(mimeType) {\n            //this would be an event that occurs after recorder has stopped lets just ignore it\n            if(this.ready===undefined || !this.ready){\n                return;\n            }\n\n\n            this.cleanup();\n        },\n\n        cancel: function() {\n            delete this.ready;\n        },\n\n        cleanup: function() {\n            this.cancel();\n        }\n\n     };//end of return value\n\n});"],"names":["define","$","log","debug","streamingtoken","socket","clone","extend","this","init","preparesocket","async","that","WebSocket","texts","onmessage","message","msg","res","JSON","parse","data","audio_start","text","keys","Object","sort","a","b","key","onopen","event","ready","onerror","close","onclose","audioprocess","audiodata","undefined","monoaudiodata","tempbuffer","i","length","sample","Math","max","min","intSample","push","sendbuffer","Uint8Array","binary","String","fromCharCode","base64","btoa","send","stringify","audio_data","finish","mimeType","cleanup","cancel"],"mappings":"AAAAA,mCAAO,CAAC,SAAU,aAAa,SAAUC,EAAGC,YAMxCA,IAAIC,MAAM,4BAEH,CAEHC,eAAgB,KAChBC,OAAQ,KAGRC,MAAO,kBACIL,EAAEM,QAAO,EAAM,GAAIC,OAG9BC,KAAM,SAASL,qBACNA,eAAiBA,oBACjBM,iBAITA,cAAeC,qBACPC,KAAOJ,UAGNH,aAAe,IAAIQ,uGACkEL,KAAKJ,uBAIzFU,MAAQ,QACTT,OAAOU,UAAaC,cACjBC,IAAM,SACJC,IAAMC,KAAKC,MAAMJ,QAAQK,MAC/BP,MAAMI,IAAII,aAAeJ,IAAIK,WACvBC,KAAOC,OAAOD,KAAKV,OACzBU,KAAKE,MAAK,CAACC,EAAGC,IAAMD,EAAIC,QACnB,MAAMC,OAAOL,KACVV,MAAMe,OACNZ,gBAAWH,MAAMe,OAGzB3B,IAAIC,MAAMc,WAGTZ,OAAOyB,OAAUC,QAClB7B,IAAIC,MAAM,6BACVS,KAAKoB,OAAQ,QAGZ3B,OAAO4B,QAAWF,QACnB7B,IAAIC,MAAM4B,OACVnB,KAAKP,OAAO6B,cAGX7B,OAAO8B,QAAWJ,QACnB7B,IAAIC,MAAM4B,OACVnB,KAAKP,OAAS,OAItB+B,aAAc,SAASC,mBAGHC,IAAb9B,KAAKwB,OAAsBxB,KAAKwB,WAI/BO,cAAgBF,UAAU,GAC1BG,WAAa,OACZ,IAAIC,EAAI,EAAGA,EAAIF,cAAcG,OAAQD,IAAK,OACrCE,OAASC,KAAKC,KAAK,EAAGD,KAAKE,IAAI,EAAGP,cAAcE,KAChDM,UAAYJ,OAAS,EAAa,MAATA,OAA2B,MAATA,OACjDH,WAAWQ,KAAiB,IAAZD,WAChBP,WAAWQ,KAAMD,WAAa,EAAK,aAEnCE,WAAa,IAAIC,WAAWV,YAG5BW,OAAS,GACJV,EAAI,EAAGA,EAAIQ,WAAWP,OAAQD,IACnCU,QAAUC,OAAOC,aAAaJ,WAAWR,QAIzCa,OAASC,KAAKJ,QAvBP3C,KAwBFH,QAxBEG,KAyBFH,OAAOmD,KACRrC,KAAKsC,UAAU,CACXC,WAAYJ,YAO5BK,OAAQ,SAASC,eAEGtB,IAAb9B,KAAKwB,OAAsBxB,KAAKwB,YAK9B6B,WAGTC,OAAQ,kBACGtD,KAAKwB,OAGhB6B,QAAS,gBACAC"}