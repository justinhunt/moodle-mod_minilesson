{"version":3,"file":"ttstreamer.min.js","sources":["../src/ttstreamer.js"],"sourcesContent":["define(['jquery', 'core/log'], function ($, log) {\n    \"use strict\"; // jshint ;_;\n    /*\n    This file is the streamer to assembly ai\n     */\n\n    log.debug('TT Streamer initialising');\n\n    return {\n\n        speechtoken: null,\n        socket: null,\n        audiohelper: null,\n        earlyaudio: [],\n        finals: [],\n        ready: false,\n        finaltext: '',\n        lang: 'en-US',\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        init: function (speechtoken, speechregion, theaudiohelper) {\n            this.speechtoken = speechtoken;\n            this.audiohelper = theaudiohelper;\n            this.lang = theaudiohelper.therecorder.lang;\n            this.preparesocket();\n        },\n\n        preparesocket: function () {\n            var that = this;\n\n            // establish wss with AssemblyAI Universal Streaming at 16000 sample rate\n            var basehost = 'wss://streaming.assemblyai.com';\n            switch (this.audiohelper.region) {\n                case 'frankfurt':\n                case 'london':\n                case 'dublin':\n                    basehost = 'wss://streaming.eu.assemblyai.com';\n                    break;\n                default:\n                    basehost = 'wss://streaming.assemblyai.com';\n            }\n\n            // First two chars of lang code\n            // Assembly AI is english or autodetect ... urgh\n            var themodel = \"universal-streaming-english\";\n            var shortlang = this.lang.slice(0, 2);\n            switch(shortlang){\n                case \"en\":\n                    themodel = \"universal-streaming-english\";\n                    break;\n                default:\n                    themodel = \"universal-streaming-multilingual\";\n            }\n\n            var query = 'sample_rate=16000&encoding=pcm_s16le&speech_model=' + themodel + '&token=' + this.speechtoken;\n            //encodeURIComponent(this.speechtoken);\n            var url = `${basehost}/v3/ws?${query}`;\n            this.ready = false;\n            this.socket = new WebSocket(url);\n            log.debug('TT Streamer socket prepared');\n\n\n            // handle incoming messages which contain the transcription\n            this.socket.onmessage = function (message) {\n                try {    \n                    const payload = JSON.parse(message.data);\n                    const eventType = payload.type || payload.message_type;\n                    log.debug('TT Streamer message type: ' + eventType);\n                    switch (eventType) {\n                        //case 'session.created':\n                        case 'Begin':\n                            that.handlesessioncreated();\n                            break;\n\n                        case 'Turn':\n                            that.handlefinalresponse(payload);\n                            break;\n                        case 'Termination':\n                            //Do something on termination if we need to\n                            break;    \n            \n                        default:\n                            break;\n                    }\n                } catch (error) {\n                    log.debug(`\\nError handling message: ${error}`);\n                    log.debug(`Message data: ${message}`);\n                }\n            };\n\n            this.socket.onopen = (event) => {\n                log.debug('TT Streamer socket opened');\n                that.finaltext = '';\n                that.finals = [];\n                that.audiohelper.onSocketReady('fromsocketopen');\n            };\n\n            this.socket.onerror = (event) => {\n                log.debug(event);\n                that.doclosesocket();\n            };\n\n            this.socket.onclose = (event) => {\n                log.debug(event);\n                that.socket = null;\n            };\n        },\n\n        updatetoken: function (newtoken) {\n            var that = this;\n            if (that.socket) {\n                that.doclosesocket();\n            }\n            that.speechtoken = newtoken;\n            that.preparesocket();\n        },\n\n        audioprocess: function (stereodata) {\n            var that = this;\n            var int16data = this.convertflattoint16(stereodata[0]);\n\n            //this would be an event that occurs after recorder has stopped or before we are ready\n            //session opening can be slower than socket opening, so store audio data until session is open\n            if (this.ready === undefined || !this.ready) {\n                log.debug('TT Streamer storing audio');\n                this.earlyaudio.push(int16data);\n\n                //session opened after we collected audio data, send earlyaudio first\n            } else if (this.earlyaudio.length > 0) {\n                for (var i = 0; i < this.earlyaudio.length; i++) {\n                    this.sendaudio(this.earlyaudio[i]);\n                }\n                //clear earlyaudio and send the audio we just got\n                this.earlyaudio = [];\n                this.sendaudio(int16data);\n\n            } else {\n                //just send the audio we got\n                // log.debug('TT Streamer sending current audiodata');\n                this.sendaudio(int16data);\n            }\n        },\n\n        convertflattoint16: function (monoaudiodata) {\n            var that = this;\n\n            //convert to 16 bit pcm\n            var tempbuffer = []\n            for (let i = 0; i < monoaudiodata.length; i++) {\n                const sample = Math.max(-1, Math.min(1, monoaudiodata[i]))\n                const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7fff\n                tempbuffer.push(intSample & 0xff)\n                tempbuffer.push((intSample >> 8) & 0xff)\n            }\n            return new Uint8Array(tempbuffer);\n        },\n\n        sendaudio: function (audiodata) {\n            var that = this;\n            //Send it off !!\n            if (that.socket && that.socket.readyState === WebSocket.OPEN) {\n                that.socket.send(audiodata);\n            }\n        },\n\n        finish: function (mimeType) {\n            var that = this;\n\n            //this would be an event that occurs after recorder has stopped lets just ignore it\n            if (this.ready === undefined || !this.ready) {\n                return;\n            }\n            log.debug('committing universal response');\n            \n            this.doclosesocket();\n              \n           \n            log.debug('setting time out to build transcript');\n            setTimeout(function () {\n                var finaltranscript = that.buildtranscript();\n                log.debug('sending final speech capture event');\n                that.audiohelper.onfinalspeechcapture(finaltranscript);\n                that.cleanup();\n            }, 1000);\n        },\n\n        cancel: function () {\n            this.ready = false;\n            this.earlyaudio = [];\n            this.finals = {};\n            this.finaltext = '';\n            if (this.socket) {\n                this.doclosesocket();\n            }\n        },\n\n        cleanup: function () {\n            this.cancel();\n        },\n\n        doclosesocket: function (){\n              var that = this;\n             // Close WebSocket connection if it's open\n            if (that.socket && [WebSocket.OPEN, WebSocket.CONNECTING].includes(that.socket.readyState)) {\n                try {\n                    // Send termination message if possible\n                    if (that.socket.readyState === WebSocket.OPEN) {\n                        const terminateMessage = { type: \"Terminate\" };\n                        console.log(\n                        `Sending termination message: ${JSON.stringify(terminateMessage)}`\n                        );\n                        that.socket.send(JSON.stringify(terminateMessage));\n                    }\n                    that.socket.close();\n                } catch (error) {\n                    console.error(`Error closing WebSocket: ${error}`);\n                }\n                that.socket = null;\n            }\n        },\n\n        handlesessioncreated: function () {\n            var that = this;\n            log.debug('TT Streamer session created');\n            this.ready = true;\n            if (this.earlyaudio.length > 0) {\n                for (var i = 0; i < this.earlyaudio.length; i++) {\n                    this.sendaudio(this.earlyaudio[i]);\n                }\n                this.earlyaudio = [];\n            }\n            this.audiohelper.onSocketReady('fromsessioncreated');\n        },\n\n\n        handlefinalresponse: function (payload) {\n            var that = this;\n            var thistranscript = payload.transcript || \"\";\n             //process finals\n            that.finals[payload.turn_order] = thistranscript;\n            that.finaltext = this.buildtranscript();\n            that.audiohelper.oninterimspeechcapture(thistranscript);\n            log.debug('TT Streamer final transcript update: ' + thistranscript);\n        },\n\n\n        \n\n        buildtranscript: function () {\n            var combined = '';\n            for (var i = 0; i < this.finals.length; i++) {\n                var text = this.finals[i];\n                if (text) {\n                    combined += (combined ? ' ' : '') + text;\n                }\n            }\n            return combined.trim();\n        }\n\n    };//end of return value\n\n});"],"names":["define","$","log","debug","speechtoken","socket","audiohelper","earlyaudio","finals","ready","finaltext","lang","clone","extend","this","init","speechregion","theaudiohelper","therecorder","preparesocket","that","basehost","region","themodel","slice","query","url","WebSocket","onmessage","message","payload","JSON","parse","data","eventType","type","message_type","handlesessioncreated","handlefinalresponse","error","onopen","event","onSocketReady","onerror","doclosesocket","onclose","updatetoken","newtoken","audioprocess","stereodata","int16data","convertflattoint16","undefined","length","i","sendaudio","push","monoaudiodata","tempbuffer","sample","Math","max","min","intSample","Uint8Array","audiodata","readyState","OPEN","send","finish","mimeType","setTimeout","finaltranscript","buildtranscript","onfinalspeechcapture","cleanup","cancel","CONNECTING","includes","terminateMessage","console","stringify","close","thistranscript","transcript","turn_order","oninterimspeechcapture","combined","text","trim"],"mappings":"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"}