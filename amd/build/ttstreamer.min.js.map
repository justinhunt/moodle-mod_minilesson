{"version":3,"file":"ttstreamer.min.js","sources":["../src/ttstreamer.js"],"sourcesContent":["define(['jquery', 'core/log'], function ($, log) {\n    \"use strict\"; // jshint ;_;\n    /*\n    This file is the engine that drives audio rec and canvas drawing. TT Recorder is the just the glory kid\n     */\n\n    log.debug('TT Streamer initialising');\n\n    return {\n\n        streamingtoken: null,\n        socket: null,\n        audiohelper: null,\n        partials: [],\n        finals: [],\n        ready: false,\n        finaltext: '',\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        init: function(streamingtoken, theaudiohelper) {\n            this.streamingtoken = streamingtoken;\n            this.audiohelper = theaudiohelper;\n            this.preparesocket();\n\n        },\n\n        preparesocket: async function(){\n            var that = this;\n\n            // establish wss with AssemblyAI (AAI) at 16000 sample rate\n            switch(this.audiohelper.region){\n                case 'frankfurt':\n                case 'london':\n                case 'dublin':\n                    //did not work\n               //     this.socket = await new WebSocket(\n               //         `wss://api.eu.assemblyai.com/v2/realtime/ws?sample_rate=16000&encoding=pcm_s16le&token=${this.streamingtoken}`,\n                //    );\n                //    break;\n                default:\n                    this.socket = await new WebSocket(\n                        `wss://api.assemblyai.com/v2/realtime/ws?sample_rate=16000&encoding=pcm_s16le&token=${this.streamingtoken}`,\n                    );\n            }\n            log.debug('TT Streamer socket prepared');\n            \n\n            // handle incoming messages which contain the transcription\n            this.socket.onmessage= function(message) {\n                let msg = \"\";\n                const res = JSON.parse(message.data);\n                switch(res.message_type){\n                    case 'PartialTranscript':\n                        that.partials[res.audio_start] = res.text;\n                        var keys = Object.keys(that.partials);\n                        keys.sort((a, b) => a - b);\n                        for (const key of keys) {\n                            if (that.partials[key]) {\n                                msg += ` ${that.partials[key]}`;\n                            }\n                        }\n                        that.audiohelper.oninterimspeechcapture(that.finaltext + ' ' + msg);\n                        break;\n\n                    case 'FinalTranscript':\n                        //clear partials if we have a final\n                        that.partials = [];\n                        //process finals\n                        that.finals[res.audio_start] = res.text;\n                        var keys = Object.keys(that.finals);\n                        keys.sort((a, b) => a - b);\n                        for (const key of keys) {\n                            if (that.finals[key]) {\n                                msg += ` ${that.finals[key]}`;\n                            }\n                        }\n                        that.finaltext = msg;\n                        //we do not send final speech capture event until the speaking session ends\n                        //that.audiohelper.onfinalspeechcapture(msg);\n                        that.audiohelper.oninterimspeechcapture(msg);\n                        log.debug('interim (final) transcript: ' + msg);\n                        break;\n                    case 'Session_Begins':\n                            break;      \n                    case 'Session_Ends':\n                            break;    \n                    case 'Session_Information':\n                        break;\n                    case 'Realtime_Error':\n                        log.debug(res.error);\n                        break;    \n                    default:\n                        break;\n                }\n                log.debug(msg);\n            };\n\n            this.socket.onopen = (event) => {\n                log.debug('TT Streamer socket opened');\n                that.ready = true;\n                that.partials = [];\n                that.finals = [];\n                that.audiohelper.onSocketReady('fromsocketopen');\n            };\n\n            this.socket.onerror = (event) => {\n                log.debug(event);\n                that.socket.close();\n            };\n\n            this.socket.onclose = (event) => {\n                log.debug(event);\n                that.socket = null;\n            };\n        },\n\n        audioprocess: function(audiodata) {\n            var that = this;\n            //this would be an event that occurs after recorder has stopped lets just ignore it\n            if(this.ready===undefined || !this.ready){\n                return;\n            }\n            //it might be stereo so we will just take the first channel\n            var monoaudiodata = audiodata[0];\n            //convert to 16 bit pcm\n            var tempbuffer = []\n            for (let i = 0; i < monoaudiodata.length; i++) {\n                const sample = Math.max(-1, Math.min(1, monoaudiodata[i]))\n                const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7fff\n                tempbuffer.push(intSample & 0xff)\n                tempbuffer.push((intSample >> 8) & 0xff)\n            }\n            var sendbuffer = new Uint8Array(tempbuffer)\n\n            // Encode binary string to base64\n            var binary = '';\n            for (var i = 0; i < sendbuffer.length; i++) {\n                binary += String.fromCharCode(sendbuffer[i]);\n            }\n            var base64 = btoa(binary);\n\n            //Send it off !!\n            if (that.socket) {\n                that.socket.send(\n                    JSON.stringify({\n                        audio_data: base64,\n                    }),\n                );\n            }\n        },\n\n\n        finish: function(mimeType) {\n            var that = this;\n\n            //this would be an event that occurs after recorder has stopped lets just ignore it\n            if(this.ready===undefined || !this.ready){\n                return;\n            }\n            log.debug('forcing end uttterance');\n            //get any remanining transcription\n            if (that.socket) {\n                that.socket.send(\n                    JSON.stringify({\n                        force_end_utterance: true,\n                    }),\n                );\n            }\n            log.debug('timing out');\n            setTimeout(function() {\n                var msg = \"\";\n                var sets = [that.finals,that.partials];\n                for (const set of sets) {\n                    var keys = Object.keys(set);\n                    keys.sort((a, b) => a - b);\n                    for (const key of keys) {\n                        if (set[key]) {\n                            msg += ` ${set[key]}`;\n                        }\n                    }\n                }\n                log.debug('sending final speech capture event');\n                that.audiohelper.onfinalspeechcapture(msg);\n                that.cleanup();\n            }, 1500);\n        },\n\n        cancel: function() {\n           this.ready = false;\n           this.partials = [];\n           this.finals = [];\n           this.finaltext = '';\n           if(this.socket){\n               this.socket.close();\n           }\n        },\n\n        cleanup: function() {\n            this.cancel();\n        }\n\n     };//end of return value\n\n});"],"names":["define","$","log","debug","streamingtoken","socket","audiohelper","partials","finals","ready","finaltext","clone","extend","this","init","theaudiohelper","preparesocket","async","that","region","WebSocket","onmessage","message","msg","res","JSON","parse","data","message_type","audio_start","text","keys","Object","sort","a","b","key","oninterimspeechcapture","error","onopen","event","onSocketReady","onerror","close","onclose","audioprocess","audiodata","undefined","monoaudiodata","tempbuffer","i","length","sample","Math","max","min","intSample","push","sendbuffer","Uint8Array","binary","String","fromCharCode","base64","btoa","send","stringify","audio_data","finish","mimeType","force_end_utterance","setTimeout","sets","set","onfinalspeechcapture","cleanup","cancel"],"mappings":"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"}